"use strict";(self.webpackChunksuse_edge_docs=self.webpackChunksuse_edge_docs||[]).push([[6705],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=p(n),m=r,h=d["".concat(s,".").concat(m)]||d[m]||c[m]||l;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[d]="string"==typeof e?e:r,o[1]=i;for(var p=2;p<l;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2540:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>i,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const l={slug:"Flexran",title:"Deploying Intel FlexRan on the SUSE Adaptive Telco Infrastructure Platform",authors:{name:"Alberto Morgante Medina",title:"Sr. Edge Telco Engineer",url:"https://github.com/alknopfler",image_url:"https://github.com/alknopfler.png"},tags:["edge","telco","flexran"]},o=void 0,i={permalink:"/blog/Flexran",source:"@site/blog/2023-07-28-flexran.md",title:"Deploying Intel FlexRan on the SUSE Adaptive Telco Infrastructure Platform",description:"Introduction",date:"2023-07-28T00:00:00.000Z",formattedDate:"July 28, 2023",tags:[{label:"edge",permalink:"/blog/tags/edge"},{label:"telco",permalink:"/blog/tags/telco"},{label:"flexran",permalink:"/blog/tags/flexran"}],readingTime:37.84,hasTruncateMarker:!1,authors:[{name:"Alberto Morgante Medina",title:"Sr. Edge Telco Engineer",url:"https://github.com/alknopfler",image_url:"https://github.com/alknopfler.png",imageURL:"https://github.com/alknopfler.png"}],frontMatter:{slug:"Flexran",title:"Deploying Intel FlexRan on the SUSE Adaptive Telco Infrastructure Platform",authors:{name:"Alberto Morgante Medina",title:"Sr. Edge Telco Engineer",url:"https://github.com/alknopfler",image_url:"https://github.com/alknopfler.png",imageURL:"https://github.com/alknopfler.png"},tags:["edge","telco","flexran"]},prevItem:{title:"Edge Computing Reference Architecture with Rancher and Linkerd",permalink:"/blog/Linkerd"},nextItem:{title:"Welcome to SUSE Edge",permalink:"/blog/welcome"}},s={authorsImageUrls:[void 0]},p=[{value:"Introduction",id:"introduction",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Hardware and Software components",id:"hardware-and-software-components",level:2},{value:"Hardware",id:"hardware",level:3},{value:"Software",id:"software",level:3},{value:"Flexran",id:"flexran",level:3},{value:"Rancher Management Cluster",id:"rancher-management-cluster",level:2},{value:"RKE2 Cluster Installation on the Management Server",id:"rke2-cluster-installation-on-the-management-server",level:3},{value:"Rancher Manager Install",id:"rancher-manager-install",level:3},{value:"Edge Cluster deployment",id:"edge-cluster-deployment",level:2},{value:"BIOS Configuration for Dell PowerEdge XR11",id:"bios-configuration-for-dell-poweredge-xr11",level:3},{value:"OS Installation",id:"os-installation",level:3},{value:"OS Configuration and Tuning",id:"os-configuration-and-tuning",level:3},{value:"RKE2 Cluster Installation",id:"rke2-cluster-installation",level:3},{value:"ACC100 Configuration",id:"acc100-configuration",level:3},{value:"DPDK Configuration",id:"dpdk-configuration",level:3},{value:"SRIOV Configuration",id:"sriov-configuration",level:3},{value:"FlexRan tests",id:"flexran-tests",level:2},{value:"References",id:"references",level:3},{value:"Prepare the files downloaded from Intel",id:"prepare-the-files-downloaded-from-intel",level:3},{value:"Container entrypoint",id:"container-entrypoint",level:3},{value:"FlexRan Timer Mode",id:"flexran-timer-mode",level:3},{value:"FlexRan Xran Mode",id:"flexran-xran-mode",level:3},{value:"Conclusion",id:"conclusion",level:2}],u={toc:p},d="wrapper";function c(e){let{components:t,...l}=e;return(0,r.kt)(d,(0,a.Z)({},u,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Intel\xae FlexRAN is a reference implementation for a virtualized 4G and 5G RAN stack. It's main purpose is to illustrate how to achieve real-time performance of a virtualized 4G or 5G PHY and MAC layer on an Intel-based hardware architecture, using Intel\xae Xeon\xae Scalable processors, the Intel\xae Advanced Vector Extensions 512 ",(0,r.kt)("inlineCode",{parentName:"p"},"Intel\xae AVX 512")," instruction set and a number of other hardware acceleration features and technologies found in modern Intel Xeon family processors. While some vendors of CloudRAN and in particular O-RAN software merely use it as inspiration, some vendors adopt Intel FlexRAN directly as part of their product.\nThis article describes how to deploy FlexRAN on the SUSE Adaptive Telco Infrastructure Platform (ATIP) running on bare-metal infrastructure as a Containerized Network Function (CNF). In the ATIP architecture, the runtime stack consists of ",(0,r.kt)("a",{parentName:"p",href:"https://www.suse.com/products/micro/"},"SUSE Linux Enterprise Micro")," and Rancher Kubernetes Engine v2 (RKE2) and we are using ",(0,r.kt)("a",{parentName:"p",href:"https://www.rancher.com/"},"Rancher")," to perform cluster and application provisioning, life cycle management, application resource management and collection of telemetry data with role-based access control.\nThe example RAN deployment option considered here is the ",(0,r.kt)("a",{parentName:"p",href:"https://www.o-ran.org/blog/20-new-o-ran-specifications-have-been-released-since-june-2020"},"ORAN Alliance 7-2x lower-level split"),", which in a nutshell means that the lower layer PHY processing for uplink and downlink (such as Cyclic Prefix addition/removal, iFFT/FFT, calculation of beamforming coefficients and PRACH pre-filtering) is performed in the Radio Unit (RU), and upper layer PHY processing as well as all MAC layer processing is performed in the Distributed Unit (DU). When DU and RU are deployed in different Kubernetes pods, this constitutes an excellent test for a telco cloud platform, as it requires near-realtime processing and transmission of fronthaul traffic over physical network interfaces, which is only possible with careful orchestration of a number of telco-grade platform features, as we will detail further below."),(0,r.kt)("p",null,"With this cloud-native setup, we can identify the appropriate configuration of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Suse Edge ATIP")," (Adaptive Telco Infrastructure Platform) stack. Also, it demostrates that telecom containerised applications like DU/CU can be run on RKE2 cluster on top of the SLE Micro RT OS taking advantage of the accelerator cards. In addition, we show that we are applying the full power and potential of the accelerator card and CPU."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"For more information about Intel FlexRan, see the official ",(0,r.kt)("a",{parentName:"p",href:"https://www.intel.com/content/www/us/en/developer/topic-technology/edge-5g/tools/flexran.html"},"Intel FlexRan website")),(0,r.kt)("p",{parentName:"blockquote"},"For more infomration about Suse ATIP, see the official ",(0,r.kt)("a",{parentName:"p",href:"https://suse-edge.github.io/docs/product/atip/introduction"},"Suse Edge ATIP documentation"))),(0,r.kt)("h2",{id:"architecture"},"Architecture"),(0,r.kt)("p",null,"The architecture is based on the following components:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Rancher Management Cluster: This component will be used to manage the lifecycle of the RKE2 clusters hosting the FlexRAN solution, as well as the monitoring platform based on the Rancher monitoring stack (Grafana and Prometheus installed on the downstream cluster). This cluster is based on a single-node RKE2 cluster on top of SLE Micro."),(0,r.kt)("li",{parentName:"ul"},"Edge Cluster 1: This cluster will be used to deploy the ",(0,r.kt)("inlineCode",{parentName:"li"},"FlexRan Timer Mode tests"),". This cluster is based on a single-node RKE2 cluster on top of SLE Micro RT Operating System."),(0,r.kt)("li",{parentName:"ul"},"Edge Cluster 2: This cluster will be used to deploy the ",(0,r.kt)("inlineCode",{parentName:"li"},"FlexRan Xran Mode tests"),". This cluster is based on a single-node RKE2 cluster on top of SLE Micro RT Operating System.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: The FlexRan tests could be deployed on the same edge cluster, but just for clarity and simplicity in the article, we will deploy them on different clusters.")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"img.png",src:n(9354).Z,width:"1525",height:"1116"})),(0,r.kt)("h2",{id:"hardware-and-software-components"},"Hardware and Software components"),(0,r.kt)("h3",{id:"hardware"},"Hardware"),(0,r.kt)("p",null,"The hardware used for this article is based on the following components:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Dell PowerEdge XR11 servers"),(0,r.kt)("li",{parentName:"ul"},"Intel XEON Gold 6338N 2.2G"),(0,r.kt)("li",{parentName:"ul"},"8 x 32GB RDIMM 3200MT/S"),(0,r.kt)("li",{parentName:"ul"},"2 x 480GB SSD SATA Disk"),(0,r.kt)("li",{parentName:"ul"},"Intel E810-CQDA2 Dual Port 100GbE QSFP28"),(0,r.kt)("li",{parentName:"ul"},"ACC100 FEC Accelerator card")),(0,r.kt)("h3",{id:"software"},"Software"),(0,r.kt)("p",null,"The software used for this article is based on the following components:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Operating system: ",(0,r.kt)("inlineCode",{parentName:"li"},"SLE Micro 5.4")),(0,r.kt)("li",{parentName:"ul"},"Kernel Real Time: ",(0,r.kt)("inlineCode",{parentName:"li"},"5.14.21-150400.15.11-rt")," "),(0,r.kt)("li",{parentName:"ul"},"RKE2 version: ",(0,r.kt)("inlineCode",{parentName:"li"},"v1.25.9+rke2r1")),(0,r.kt)("li",{parentName:"ul"},"CNI plugins: ",(0,r.kt)("inlineCode",{parentName:"li"},"Multus 0.3.1")," and  ",(0,r.kt)("inlineCode",{parentName:"li"},"Calico v3.25.0")),(0,r.kt)("li",{parentName:"ul"},"Rancher release: ",(0,r.kt)("inlineCode",{parentName:"li"},"rancher-stable v2.7.5")),(0,r.kt)("li",{parentName:"ul"},"Dpdk version: ",(0,r.kt)("inlineCode",{parentName:"li"},"22.11")),(0,r.kt)("li",{parentName:"ul"},"SRIOV upstream ",(0,r.kt)("inlineCode",{parentName:"li"},"v3.5.1"))),(0,r.kt)("h3",{id:"flexran"},"Flexran"),(0,r.kt)("p",null,"The FlexRan deployment used for this article is based on the following components:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"FlexRAN version: ",(0,r.kt)("inlineCode",{parentName:"li"},"22.07")," using ",(0,r.kt)("a",{parentName:"li",href:"https://hub.docker.com/r/intel/flexran_vdu"},"pre-defined containers")," from Intel."),(0,r.kt)("li",{parentName:"ul"},"Intel OneAPI Base Toolkit: ",(0,r.kt)("inlineCode",{parentName:"li"},"2022.1.2.146"))),(0,r.kt)("h2",{id:"rancher-management-cluster"},"Rancher Management Cluster"),(0,r.kt)("p",null,"In our case, the Rancher management cluster will be used to manage the lifecycle of the RKE2 edge clusters deployed for the FlexRAN solution, as well as the monitoring platform based on Grafana and Prometheus."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"img.png",src:n(7154).Z,width:"449",height:"351"})),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The operating system installation steps have been omitted for the sake of brevity. There are no special performance-related configuration settings required for the OS on the management cluster.\nFor more information about how to install the Operating System, see the next ",(0,r.kt)("a",{parentName:"p",href:"https://suse-edge.github.io/docs/product/atip/management-cluster"},"link"))),(0,r.kt)("h3",{id:"rke2-cluster-installation-on-the-management-server"},"RKE2 Cluster Installation on the Management Server"),(0,r.kt)("p",null,"Once you have the Operating System installed, you can proceed with the Rancher installation. First, we will install a RKE2 cluster and then, the Rancher Helm chart to install the Rancher management cluster."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Run the RKE2 installer:")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"curl -sfL https://get.rke2.io | sh -")),(0,r.kt)("p",null,"if you want to install a particular version, the ",(0,r.kt)("inlineCode",{parentName:"p"},"INSTALL_RKE2_VERSION")," variable can be used as:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},'curl -sfL https://get.rke2.io | INSTALL_RKE2_VERSION="v1.25.9+rke2r1" sh -')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"For more information about the installation, please refer to the documentation: ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rke2.io/install/install_options/"},"https://docs.rke2.io/install/install_options/"))),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Enable and start the rke2-server service:")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"systemctl enable --now rke2-server.service")),(0,r.kt)("p",null,"In case you want to run the RKE2 agent (in case you need to add more nodes designated to run your apps and services), you can follow the next steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Run the RKE2 installer:")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},'curl -sfL https://get.rke2.io | INSTALL_RKE2_TYPE="agent" sh -')),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Configure the config.yaml file located in ",(0,r.kt)("inlineCode",{parentName:"li"},"/etc/rancher/rke2/")," with the following content:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"server: https://<server>:9345\ntoken: <token from server node>\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Enable and start the service:")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"systemctl enable --now rke2-agent.service")),(0,r.kt)("h3",{id:"rancher-manager-install"},"Rancher Manager Install"),(0,r.kt)("p",null,"Rancher is installed using the Helm package manager for Kubernetes.\nHelm charts provide templating syntax for Kubernetes YAML manifest documents. With Helm, we can create configurable deployments instead of just using static files."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"This section covers the deployment of Rancher on the management cluster."),(0,r.kt)("p",{parentName:"blockquote"},"For more information about the Rancher manager installation, please refer to the documentation: ",(0,r.kt)("a",{parentName:"p",href:"https://ranchermanager.docs.rancher.com/v2.7/pages-for-subheaders/install-upgrade-on-a-kubernetes-cluster"},"https://ranchermanager.docs.rancher.com/v2.7/pages-for-subheaders/install-upgrade-on-a-kubernetes-cluster"))),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Add the Helm repository")),(0,r.kt)("p",null,"There are three Rancher manager releases available to be added as a Helm repository for Rancher. In our case, we will use the ",(0,r.kt)("inlineCode",{parentName:"p"},"rancher-stable")," because it's the release recommended for production environments, but you could use ",(0,r.kt)("inlineCode",{parentName:"p"},"rancher-latest")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"rancher-alpha")," if you want. Also, there is a ",(0,r.kt)("inlineCode",{parentName:"p"},"rancher primer")," release that is the enterprise version of Rancher."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"helm repo add rancher-stable https://releases.rancher.com/server-charts/stable")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"If you don't have ",(0,r.kt)("inlineCode",{parentName:"p"},"helm")," installed previously, you could install it using the following command:"),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("inlineCode",{parentName:"p"},"curl -fsSL https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 |bash"))),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Choose your SSL Configuration")),(0,r.kt)("p",null,"The Rancher management server is designed to be secure by default and requires SSL/TLS configuration."),(0,r.kt)("p",null,"There are three recommended options for SSL/TLS configuration:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Rancher-generated TLS certificate"),(0,r.kt)("li",{parentName:"ul"},"Let's Encrypt"),(0,r.kt)("li",{parentName:"ul"},"Bring your own certificate")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"For more information about the SSL/TLS configuration, please refer to the documentation: ",(0,r.kt)("a",{parentName:"p",href:"https://ranchermanager.docs.rancher.com/v2.7/pages-for-subheaders/install-upgrade-on-a-kubernetes-cluster/#3-choose-your-ssl-configuration"},"https://ranchermanager.docs.rancher.com/v2.7/pages-for-subheaders/install-upgrade-on-a-kubernetes-cluster/#3-choose-your-ssl-configuration"))),(0,r.kt)("p",null,"In our case we will use the Rancher-generated TLS certificate. This requires ",(0,r.kt)("inlineCode",{parentName:"p"},"cert-manager")," to be deployed in the cluster as::"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"helm repo add jetstack https://charts.jetstack.io\nhelm repo update\nhelm install cert-manager jetstack/cert-manager \\\n        --namespace cert-manager \\\n        --create-namespace \\\n        --set installCRDs=true \\\n        --version v1.11.1 \n")),(0,r.kt)("p",null,"Once you've installed cert-manager, you can verify the pods are running:\n",(0,r.kt)("inlineCode",{parentName:"p"},"kubectl get pods --namespace cert-manager")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Install Rancher with Helm using the following command modifying the ",(0,r.kt)("inlineCode",{parentName:"li"},"<hostname>")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"<bootstrapPassword>")," values to fit your environment:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"helm install rancher rancher-stable/rancher \\\n        --namespace cattle-system \\\n        --create-namespace \\\n        --set hostname=<hostname> \\\n        --set bootstrapPassword=<bootstrapPassword> \\\n        --set replicas=1 \\\n        --set global.cattle.psp.enabled=false\n")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},"Verify the Rancher installation")),(0,r.kt)("p",null,"You should wait a few minutes for Rancher to be rolled out:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"kubectl -n cattle-system rollout status deploy/rancher")),(0,r.kt)("h2",{id:"edge-cluster-deployment"},"Edge Cluster deployment"),(0,r.kt)("p",null,"This section covers the bare-metal provisioning and installation of the edge cluster nodes in order to deploy the FlexRan tests. In our case, we will deploy two edge clusters, one for the FlexRan Timer Mode tests and another one for the FlexRan Xran Mode tests.\nThe configuration of the edge cluster nodes is based on the following components, and it will be the same for the two edge clusters:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"img.png",src:n(3113).Z,width:"472",height:"1031"})),(0,r.kt)("h3",{id:"bios-configuration-for-dell-poweredge-xr11"},"BIOS Configuration for Dell PowerEdge XR11"),(0,r.kt)("p",null,"The BIOS and NIC configuration used for this article based on the ",(0,r.kt)("a",{parentName:"p",href:"/blog/Flexran#hardware"},"hardware")," shown above, could be imported directly using the ",(0,r.kt)("a",{target:"_blank",href:n(8181).Z},"Dell PowerEdge XR11 BIOS Exported Configuration File"),".\nIn order to import the configuration file, you need to do it using the idrac web interface:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"img.png",src:n(9298).Z,width:"1912",height:"635"})),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("em",{parentName:"p"},"Note"),": This configuration depends on the hardware vendor, so please, check with your hardware vendor the best configuration to be used.")),(0,r.kt)("p",null,"Pay special attention to the parameters suggested here as some of them could dramatically increase or decrease the performance of the tests being executed.\nThe next table shows the recommended configuration as a reference for the most common hardware vendors:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Option"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Workload Profile"),(0,r.kt)("td",{parentName:"tr",align:null},"Telco Optimized"),(0,r.kt)("td",{parentName:"tr",align:null},"Telco profile to optimize the performance in the hardware.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Boot Performance Mode"),(0,r.kt)("td",{parentName:"tr",align:null},"Max. Performance"),(0,r.kt)("td",{parentName:"tr",align:null},"Maximize the performance in the boot process.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Hyper- Threading (Logical Proccesor)"),(0,r.kt)("td",{parentName:"tr",align:null},"Enable"),(0,r.kt)("td",{parentName:"tr",align:null},"This option enables Intel\xae Hyper-Threading Technology for logical processor enabling and converting processor cores (pCores) to logical cores (lCores).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Virtualization Technology (XAPIC)"),(0,r.kt)("td",{parentName:"tr",align:null},"Enable"),(0,r.kt)("td",{parentName:"tr",align:null},"This option is for Extended Advanced Programmable Interrupt Controller (xAPIC) support for the Intel\xae Virtualization Technology for Directed I/O (Intel\xae VT-d) feature.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uncore frequency scaling"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"If enabled, Uncore Frequency Scaling (UFS) allows the uncore to operate at a lower frequency when the Power Control Unit (PCU) has detected low utilization. Conversely, UFS allows the uncore to operate at a higher frequency when the PCU has detected high utilization.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CPU P-State Control (EIST PSD Function"),(0,r.kt)("td",{parentName:"tr",align:null},"HW_ALL"),(0,r.kt)("td",{parentName:"tr",align:null},"optimization of the voltage and CPU fequency during operation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CPU C-State Control"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"This option is for the CPU C-State Control feature, which provides power savings by placing the processor into lower power states when the processor is idle.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CPU C1E Support"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"This option is for the CPU Enhanced Halt (C1E) feature, which provides power savings by placing the processor into a low power state when the processor is idle.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AVX License Pre-Grant"),(0,r.kt)("td",{parentName:"tr",align:null},"Enable"),(0,r.kt)("td",{parentName:"tr",align:null},"If enabled, this option enables the pre-grant license level selection based on workload with the AVX ICCP Pre-Grant Level option.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AVX ICCP Pre- Grant Level"),(0,r.kt)("td",{parentName:"tr",align:null},"Level 5"),(0,r.kt)("td",{parentName:"tr",align:null},"This option selects a workload level for the Intel\xae Advanced Vector Extensions (Intel\xae AVX): Intel\xae AVX-512 Heavy")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AVX P1"),(0,r.kt)("td",{parentName:"tr",align:null},"Level 2"),(0,r.kt)("td",{parentName:"tr",align:null},"This option serves a dual purpose: 1 -Specifies the base P1 ratio for Intel\xae Streaming SIMD Extensions (Intel\xae SSE) or Intel\xae AVX workloads. 2- Pre-grants a license level based on the workload level.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Energy Efficient Turbo"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows entry into the Intel\xae Turbo Boost Technology frequency when the Power Control Unit (PCU) has detected high utilization.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Turbo Mode"),(0,r.kt)("td",{parentName:"tr",align:null},"Enable"),(0,r.kt)("td",{parentName:"tr",align:null},"Enabling this Intel\xae Turbo Boost Technology mode setting allows the CPU cores to operate at higher than the rated frequency.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GPSS timer"),(0,r.kt)("td",{parentName:"tr",align:null},"0us"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows the reduction of the Global P-State Selection (GPSS) timer to be set from: 0 \u03bcs to 500 \u03bcs")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LLC prefetch"),(0,r.kt)("td",{parentName:"tr",align:null},"Enable"),(0,r.kt)("td",{parentName:"tr",align:null},"This option enables Last Level Cache (LLC) hardware prefetch logic.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Frequency Prioritization (RAPL Prioritization)"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"This setting controls whether the Running Average Power Limit (RAPL) balancer is enabled. If enabled, it activates per core power budgeting.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Hardware P-States"),(0,r.kt)("td",{parentName:"tr",align:null},"Native with no Legacy Support"),(0,r.kt)("td",{parentName:"tr",align:null},"When enabled, this option allows the hardware to choose a Performance State (P-State) based on an OS request (that is, a legacy P-State).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"EPP enable3"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"When this option is enabled, the system uses the energy performance bias register for the Energy Performance Preference (EPP) input to make decision on Performance State (P-State) or Processor Core Idle State (C-State) transitions.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"APS Rocketing"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"Rocketing mechanism in the HWP p-state selection for pcode algorithm. Rocketing enables the core ratio to jump to max turbo instantaneously as opposed to a smooth ramp")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Scalability"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"Core Performance to frequency scalability based on optimizations in the CPU.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Native ASPM"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"ASPM off not controlled by BIOS or OS.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Power Performance Tuning"),(0,r.kt)("td",{parentName:"tr",align:null},"OS Controls EPB"),(0,r.kt)("td",{parentName:"tr",align:null},"This option selects the BIOS or OS that controls the Energy Performance Bias (EPB) functionality.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Workload Configuration"),(0,r.kt)("td",{parentName:"tr",align:null},"I/O sensitive"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows the system power and performance profile to be set to favor compute intensive workload or I/O sensitive workload.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Dynamic L1"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"This option applies only to the package-level setting to allow dynamically entering the lower power link state L1.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Set Fan Profile"),(0,r.kt)("td",{parentName:"tr",align:null},"Performance"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows the fan profile to be set to Performance, Balanced, or Quiet.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Cooling Configuration - Fan Speed Offset"),(0,r.kt)("td",{parentName:"tr",align:null},"Medium"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows the fan speed offset to be set to Low, Medium, or High.")))),(0,r.kt)("h3",{id:"os-installation"},"OS Installation"),(0,r.kt)("p",null,"For this example, we will assume the SLE Micro RT 5.4 operating system has been already installed on the baremetal host used to deploy the edge clusters. To verify the ",(0,r.kt)("inlineCode",{parentName:"p"},"Real Time Kernel")," version used, you can use the following command (pay attention to the ",(0,r.kt)("inlineCode",{parentName:"p"},"-rt")," suffix):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"uname -r\n5.14.21-150400.15.11-rt\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"If you want to download the SLE Micro RT 5.4 ISO, you can use the following link paying special attention to the ",(0,r.kt)("inlineCode",{parentName:"p"},"-RT")," in the image name, once you've logged in with your SUSE credentials: ",(0,r.kt)("a",{parentName:"p",href:"https://www.suse.com/download/sle-micro/"},"Download SLE Micro RT from Suse Customer Center"))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"For more information about how to install the operating system SLE Micro RT, see the next ",(0,r.kt)("a",{parentName:"p",href:"https://suse-edge.github.io/docs/product/atip/management-cluster#os-install"},"link"))),(0,r.kt)("h3",{id:"os-configuration-and-tuning"},"OS Configuration and Tuning"),(0,r.kt)("p",null,"Once you have the Operating System installed, you can proceed with the Operating System configuration. For this article, we will configure the Operating System using the next steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"CPU Tuned Configuration")),(0,r.kt)("p",null,"The first thing is to create a profile for the CPU cores we want to isolate. In this case, we will isolate the cores 1-30 and 33-62 to be used by FlexRan, keeping also some cores available for the system."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'echo "export tuned_params" >> /etc/grub.d/00_tuned\n\necho "isolated_cores=1-30,33-62" >> /etc/tuned/cpu-partitioning-variables.conf\n\nsystemctl enable tuned; systemctl start tuned\n\ntuned-adm profile cpu-partitioning\n')),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Grub Configuration")),(0,r.kt)("p",null,"We need to modify some grub options to be able to do the CPU isolation as well as another important parameters for the CPU performance on this scenario."),(0,r.kt)("p",null,"The following options have to be customized:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"value"),(0,r.kt)("th",{parentName:"tr",align:null},"description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"isolcpu"),(0,r.kt)("td",{parentName:"tr",align:null},"1-30,33-62"),(0,r.kt)("td",{parentName:"tr",align:null},"Isolate the cores 1-30 and 33-62")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"skew_tick"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Allows the kernel to skew the timer interrupts across the isolated CPUs.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nohz"),(0,r.kt)("td",{parentName:"tr",align:null},"on"),(0,r.kt)("td",{parentName:"tr",align:null},"Allows the kernel to run the timer tick on a single CPU when the system is idle.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nohz_full"),(0,r.kt)("td",{parentName:"tr",align:null},"1-30,33-62"),(0,r.kt)("td",{parentName:"tr",align:null},"kernel boot parameter is the current main interface to configure full dynticks along with CPU Isolation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rcu_nocbs"),(0,r.kt)("td",{parentName:"tr",align:null},"1-30,33-62"),(0,r.kt)("td",{parentName:"tr",align:null},"Allows the kernel to run the RCU callbacks on a single CPU when the system is idle.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"kthread_cpus"),(0,r.kt)("td",{parentName:"tr",align:null},"0,31,32,63"),(0,r.kt)("td",{parentName:"tr",align:null},"Allows the kernel to run the kthreads on a single CPU when the system is idle.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"irqaffinity"),(0,r.kt)("td",{parentName:"tr",align:null},"0,31,32,63"),(0,r.kt)("td",{parentName:"tr",align:null},"Allows the kernel to run the interrupts on a single CPU when the system is idle.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"processor.max_cstate"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Prevents the CPU from dropping into a sleep state when idle")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"intel_idle.max_cstate"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"Disables the intel_idle driver and allows acpi_idle to be used")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"iommu"),(0,r.kt)("td",{parentName:"tr",align:null},"pt"),(0,r.kt)("td",{parentName:"tr",align:null},"Allows to use vfio for the dpdk interfaces")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"intel_iommu"),(0,r.kt)("td",{parentName:"tr",align:null},"on"),(0,r.kt)("td",{parentName:"tr",align:null},"Enables to use vfio for VFs.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hugepagesz"),(0,r.kt)("td",{parentName:"tr",align:null},"1G"),(0,r.kt)("td",{parentName:"tr",align:null},"Allows to set the size of huge pages to 1G")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hugepages"),(0,r.kt)("td",{parentName:"tr",align:null},"40"),(0,r.kt)("td",{parentName:"tr",align:null},"Number of hugepages defined before")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"default_hugepagesz"),(0,r.kt)("td",{parentName:"tr",align:null},"1G"),(0,r.kt)("td",{parentName:"tr",align:null},"Default value to enable huge pages")))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"For mor information about theses parameters, please refer to the next ",(0,r.kt)("a",{parentName:"p",href:"https://suse-edge.github.io/docs/product/atip/features"},"link"))),(0,r.kt)("p",null,"With the values showed above, we are isolating 60 cores, and we are using 4 cores for the OS."),(0,r.kt)("p",null,"We can modify the grub config as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'vi /etc/default/grub\n    GRUB_CMDLINE_LINUX="intel_iommu=on intel_pstate=passive processor.max_cstate=1 intel_idle.max_cstate=0 iommu=pt usbcore.autosuspend=-1 selinux=0 enforcing=0 nmi_watchdog=0 crashkernel=auto softlockup_panic=0 audit=0 mce=off hugepagesz=1G hugepages=40 hugepagesz=2M hugepages=0 default_hugepagesz=1G kthread_cpus=0,31,32,63 irqaffinity=0,31,32,63 isolcpu=1-30,33-62 skew_tick=1 nohz_full=1-30,33-62 rcu_nocbs=1-30,33-62 rcu_nocb_poll"\n\ntransactional-update grub.cfg\n')),(0,r.kt)("p",null,"To validate that the parameters are applied after reboot, you could check:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"cat /proc/cmdline\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Compile the DPDK drivers")),(0,r.kt)("p",null,"In order to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"igb_uio")," driver, which is necessary for the ACC100 acceleration card, we need to compile the DPDK drivers for the SLE Micro RT kernel.\nThe process to build the ",(0,r.kt)("inlineCode",{parentName:"p"},"igb_uio")," driver will be explained in this section, but if you don't want to deal with the compilation, you can also download the compiled driver for ",(0,r.kt)("inlineCode",{parentName:"p"},"SLE Micro RT 5.4")," rpm files from ",(0,r.kt)("a",{target:"_blank",href:n(4379).Z},"here"),"."),(0,r.kt)("p",null,"To do that, we will use an auxiliary virtual machine (only to compile and generate the rpm files) with ",(0,r.kt)("inlineCode",{parentName:"p"},"SLE-RT 15 SP4 kernel")," that you can download from ",(0,r.kt)("a",{parentName:"p",href:"https://www.suse.com/download/sle-rt/"},"here"),"."),(0,r.kt)("p",null,"Once you have available your virtual machine with the SLE 15 SP4 installed you need to verify ",(0,r.kt)("inlineCode",{parentName:"p"},"-rt")," in the kernel to ensure we will compile for a real time kernel."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"uname -r\n5.14.21-150400.15.53-rt\n")),(0,r.kt)("p",null,"The first thing you have to do to compile the driver is to download the ",(0,r.kt)("inlineCode",{parentName:"p"},"dpdk")," source code from the ",(0,r.kt)("a",{parentName:"p",href:"http://dpdk.org/git/dpdk-kmods"},"DPDK repository"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"git clone http://dpdk.org/git/dpdk-kmods\n")),(0,r.kt)("p",null,"Once you have the source code, you can compile the driver using the following commands:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"cd dpdk-kmods/igb_uio\nmake -C /lib/modules/`uname -r`/build M=`pwd` modules\n")),(0,r.kt)("p",null,"With this command you will get the ",(0,r.kt)("inlineCode",{parentName:"p"},"igb_uio.ko")," driver compiled. But in our case, we will create a rpm package to be able to install it in the SLE Micro RT kernel."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"First create an x509.genkey setup to define the type of key we need:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'echo -e "[ req ] \\n\\\ndefault_bits = 4096 \\n\\\ndistinguished_name = req_distinguished_name \\n\\\nprompt = no \\n\\\nx509_extensions = myexts \\n\\\n\n[ req_distinguished_name ] \\n\\\nCN = Modules \\n\\\n\\n\\\n[ myexts ] \\n\\\nbasicConstraints=critical,CA:FALSE \\n\\\nkeyUsage=digitalSignature \\n\\\nsubjectKeyIdentifier=hash \\n\\\nauthorityKeyIdentifier=keyid" > x509.genkey\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Then create the certificates based on these:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"openssl req -new -nodes -utf8 -sha512 -days 36500 -batch -x509 -config x509.genkey -outform DER -out signing_key.x509 -keyout signing_key.priv\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'Note: The signing key instruction are only used for testing, please create "proper" certificates for production usage.')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Install ",(0,r.kt)("inlineCode",{parentName:"li"},"build"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"kernel-rt")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"kernel-devel-rt"),"  to create the rpm package:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"zypper in build kernel-rt kernel-devel-rt\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Modify the config file to adapt it for the RT kernel:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"cp /usr/lib/build/configs/sle15.4.conf /usr/lib/build/configs/sle15.4-rt.conf\nsed -e 's/kernel-default/kernel-rt/g' -i /usr/lib/build/configs/sle15.4-rt.conf\necho \"Prefer: wicked\" >> /usr/lib/build/configs/sle15.4-rt.conf\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Prepare the spec file:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'cat << EOF >> igb_uio.spec\n#\n# spec file for package igb_uio kmp\n#\n# Copyright (c) 2023 SUSE LINUX GmbH, Nuernberg, Germany.\n#\n# All modifications and additions to the file contributed by third parties\n# remain the property of their copyright owners, unless otherwise agreed\n# upon. The license for this file, and modifications and additions to the\n# file, is the same license as for the pristine package itself (unless the\n# license for the pristine package is not an Open Source License, in which\n# case the license is the MIT License). An "Open Source License" is a\n# license that conforms to the Open Source Definition (Version 1.9)\n# published by the Open Source Initiative.\n\n# Please submit bugfixes or comments via http://bugs.opensuse.org/\n#\n\n\n# norootforbuild\n\nName:               igb_uio\nVersion:                1.0\nRelease:                0\nSummary:                Kernel Module Package for igb_uio module\nLicense:                GPL-2.0\nGroup:              System/Kernel\nURL:                    https://www.suse.com\n#Git-Clone:     http://dpdk.org/git/dpdk-kmods\nSource0:                %{name}-%{version}.tar.gz\n# Required to sign modules:  Include certificate named \u201csigning_key.x509\u201d\n# Build structure should also include a private key named \u201csigning_key.priv\u201d\n# Private key should not be listed as a source file\nSource1:        signing_key.x509\nBuildRequires:  %kernel_module_package_buildreqs\nBuildRequires:  kernel-rt\nBuildRequires:  kernel-rt-devel\n#BuildRequires:  bash-sh\n#BuildRequires:  libelf-devel\n#BuildRequires:  systemd\n#BuildRequires:  pam-config\n#BuildRequires:  libffi7\n#BuildRequires:  ghc-bootstrap\nBuildRoot:      %{_tmppath}/%{name}-%{version}-build\n\n# Required to sign modules:  The -c option tells the macro to generate a\n# suse-hello-ueficert subpackage that enrolls the certificate\n%suse_kernel_module_package -c %_sourcedir/signing_key.x509\n\n%description\nThis package contains the igb_uio.ko module.\n\n%prep\n%setup\n# Required to sign modules:  Copy the signing key to the build area\ncp %_sourcedir/signing_key.* .\nset -- *\nmkdir source\nmv "$@" source/\nmkdir obj\n\n%build\nfor flavor in %flavors_to_build; do\n       rm -rf obj/$flavor\n       cp -r source obj/$flavor\n       make -C %{kernel_source $flavor} modules M=$PWD/obj/$flavor\ndone\n\n%install\nexport INSTALL_MOD_PATH=$RPM_BUILD_ROOT\nexport INSTALL_MOD_DIR=updates\nfor flavor in %flavors_to_build; do\n       make -C %{kernel_source $flavor} modules_install M=$PWD/obj/$flavor\n       # Required to sign modules:  Invoke kernel-sign-file to sign each module\n       for x in $(find $INSTALL_MOD_PATH/lib/modules/*-$flavor/ -name \'*.ko\'); do\n               /usr/lib/rpm/pesign/kernel-sign-file -i pkcs7 sha256 $PWD/obj/$flavor/signing_key.priv $PWD/obj/$flavor/signing_key.x509 $x\n       done\ndone\n\n%changelog\n* Fri Jun 9 2023 Rhys Oxenham <rhys.oxenham@suse.com> - 1.0\n- Initial spec file as base\nEOF\n\ncat << EOF >> Kbuild\nccflags-y := $(MODULE_CFLAGS)\nobj-m := igb_uio.o\nEOF\n\n\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create the rpm packages:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"build --dist /usr/lib/build/configs/sle15.4-rt.conf\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"After creating the rpm files, the packages will be located here: ",(0,r.kt)("inlineCode",{parentName:"li"},"/var/tmp/build-root/home/abuild/rpmbuild/RPMS/x86_64"))),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},"Install the dependencies.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"transactional-update shell\n\ncat > /etc/zypp/repos.d/flexran-dependencies.repo << EOF\n[home_amorgante_branches_home_dpitchumani]\nname=Branch project for package DPDK-22.11 (15.4)\ntype=rpm-md\nbaseurl=https://download.opensuse.org/repositories/home:/amorgante:/branches:/home:/dpitchumani/15.4/\ngpgcheck=1\ngpgkey=https://download.opensuse.org/repositories/home:/amorgante:/branches:/home:/dpitchumani/15.4/repodata/repomd.xml.key\nenabled=1\n\n[home_amorgante]\nname=home:amorgante (15.4)\ntype=rpm-md\nbaseurl=https://download.opensuse.org/repositories/home:/amorgante/15.4/\ngpgcheck=1\ngpgkey=https://download.opensuse.org/repositories/home:/amorgante/15.4/repodata/repomd.xml.key\nenabled=1\nEOF\n")),(0,r.kt)("p",null,"Now, we can install the dependencies (*.rpm files) with the igb_uio driver compiled previously (or downloaded from ",(0,r.kt)("a",{target:"_blank",href:n(4379).Z},"here"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"\n```shell\nsuseconnect -p PackageHub/15.4/x86_64\nzypper in *.rpm\nzypper in dpdk dpdk-tools pf-bb-config pciutils \n\nexit\n")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},"CPU Performance")),(0,r.kt)("p",null,"Further improve the deterministic and power efficiency:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"cpupower frequency-set -g performance")),(0,r.kt)("p",null,"Set cpu core frequency to 2.6Ghz which is the maximum allowed in our case (based on the hardware):"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"cpupower frequency-set -u 2500000")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"cpupower frequency-set -d 2500000")),(0,r.kt)("p",null,"Set cpu uncore to fixed \u2013 maximum allowed. Disable c6 and c1e in order to disable the powersaving features in your system (only if enabled):"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"cpupower idle-set -d 3")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"cpupower idle-set -d 2")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"In case you've got the following message ",(0,r.kt)("inlineCode",{parentName:"p"},"Idlestate 3 not available on CPU x")," you can ignore it, because that's means that the idle state is already disabled.")),(0,r.kt)("ol",{start:6},(0,r.kt)("li",{parentName:"ol"},"Check the CPU performance")),(0,r.kt)("p",null,"You should see the driver intel_cpufreq and the governor performance with a frequency range between 2.5 and 2.6Ghz:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'cpupower frequency-info\n...\nanalyzing CPU 0:\n  driver: intel_cpufreq\n  CPUs which run at the same hardware frequency: 0\n  CPUs which need to have their frequency coordinated by software: 0\n  maximum transition latency: 20.0 us\n  hardware limits: 800 MHz - 3.50 GHz\n  available cpufreq governors: ondemand performance schedutil\n  current policy: frequency should be within 800 MHz and 3.50 GHz.\n                  The governor "performance" may decide which speed to use\n                  within this range.\n  current CPU frequency: Unable to call hardware\n  current CPU frequency: 2.60 GHz (asserted by call to kernel)\n  boost state support:\n    Supported: yes\n    Active: yes\n...\n')),(0,r.kt)("h3",{id:"rke2-cluster-installation"},"RKE2 Cluster Installation"),(0,r.kt)("p",null,"The RKE2 installation could be done creating a new cluster from the Rancher UI or importing an existing RKE2 cluster to Rancher.\nIn our case, for brevity we will install a new RKE2 Cluster from scratch importing it after that directly into Rancher."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"If you want to install the RKE2 cluster from the Rancher UI you can follow ",(0,r.kt)("a",{parentName:"p",href:"https://suse-edge.github.io/docs/product/atip/edge-site#edge-site-definition"},"this document"))),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Run the RKE2 installer:")),(0,r.kt)("p",null,"In this scenario we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"v1.25.9+rke2r1")," version as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'curl -sfL https://get.rke2.io | INSTALL_RKE2_VERSION="v1.25.9+rke2r1" sh -\n')),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Create the ",(0,r.kt)("inlineCode",{parentName:"li"},"/etc/rancher/rke2/config.yaml")," file (and the rancher/rke2 directory) with the following content to enable ",(0,r.kt)("inlineCode",{parentName:"li"},"Multus + Calico")," CNI plugins:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"cni:\n  - multus\n  - calico\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Start rke2-server service:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"systemctl daemon-reload && systemctl enable --now rke2-server\n")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},"Check the installation")),(0,r.kt)("p",null,"Make sure the calico and multus pods are running:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ kubectl get pods -A\nNAMESPACE         NAME                                                    READY   STATUS      RESTARTS   AGE\ncalico-system     calico-kube-controllers-687bc88ddf-6dp4r                1/1     Running     0          3m13s\ncalico-system     calico-node-jkhx9                                       1/1     Running     0          3m13s\ncalico-system     calico-typha-869bd9756d-ft4bs                           1/1     Running     0          3m13s\nkube-system       cloud-controller-manager-xr11-2                         1/1     Running     0          3m49s\nkube-system       etcd-xr11-2                                             1/1     Running     0          3m47s\nkube-system       helm-install-rke2-calico-crd-q2cp2                      0/1     Completed   0          3m36s\nkube-system       helm-install-rke2-calico-nv4rn                          0/1     Completed   1          3m36s\nkube-system       helm-install-rke2-coredns-55k9x                         0/1     Completed   0          3m36s\nkube-system       helm-install-rke2-ingress-nginx-fvmp4                   0/1     Completed   0          3m36s\nkube-system       helm-install-rke2-metrics-server-d2dhz                  0/1     Completed   0          3m36s\nkube-system       helm-install-rke2-multus-mm59z                          0/1     Completed   0          3m36s\nkube-system       helm-install-rke2-snapshot-controller-crd-vbcjb         0/1     Completed   0          3m36s\nkube-system       helm-install-rke2-snapshot-controller-jw6pk             0/1     Completed   0          3m36s\nkube-system       helm-install-rke2-snapshot-validation-webhook-w5sj2     0/1     Completed   0          3m36s\nkube-system       kube-apiserver-xr11-2                                   1/1     Running     0          3m53s\nkube-system       kube-controller-manager-xr11-2                          1/1     Running     0          3m51s\nkube-system       kube-proxy-xr11-2                                       1/1     Running     0          3m48s\nkube-system       kube-scheduler-xr11-2                                   1/1     Running     0          3m51s\nkube-system       rke2-coredns-rke2-coredns-6b9548f79f-bc54n              1/1     Running     0          3m26s\nkube-system       rke2-coredns-rke2-coredns-autoscaler-57647bc7cf-bfggl   1/1     Running     0          3m26s\nkube-system       rke2-ingress-nginx-controller-6vsgf                     1/1     Running     0          2m18s\nkube-system       rke2-metrics-server-7d58bbc9c6-qjkvr                    1/1     Running     0          2m33s\nkube-system       rke2-multus-ds-4zsqr                                    1/1     Running     0          3m26s\nkube-system       rke2-snapshot-controller-7b5b4f946c-rhtxn               1/1     Running     0          2m32s\nkube-system       rke2-snapshot-validation-webhook-7748dbf6ff-cfmpm       1/1     Running     0          2m1s\ntigera-operator   tigera-operator-7bd6b54cb8-2jm92                        1/1     Running     0          3m23s\n")),(0,r.kt)("h3",{id:"acc100-configuration"},"ACC100 Configuration"),(0,r.kt)("p",null,"The ACC100 accelerator card is a PCIe card that provides hardware acceleration for the Forward Error Correction (FEC) algorithm. This card is used by the FlexRan library to improve the performance of the DU/CU components."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Load the ",(0,r.kt)("inlineCode",{parentName:"li"},"igb_uio")," kernel module")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"During the OS configuration section we have installed the ",(0,r.kt)("inlineCode",{parentName:"p"},"igb")," driver, ",(0,r.kt)("inlineCode",{parentName:"p"},"dpdk")," as well as the ",(0,r.kt)("inlineCode",{parentName:"p"},"pf-bb-config")," tool ",(0,r.kt)("a",{parentName:"p",href:"#os-configuration-and-tunning"},"requirements"))),(0,r.kt)("p",null,"We will start configuring the Accelerator Card by loading the ",(0,r.kt)("inlineCode",{parentName:"p"},"ibg_uio")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"vfio-pci")," module."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"modprobe igb_uio\nmodprobe vfio-pci\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Get the interface ACC100 PCI address:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"/sbin/lspci | grep -i acc\n8a:00.0 Processing accelerators: Intel Corporation Device 0d5c\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Bind the Physical Function (PF) with the ",(0,r.kt)("inlineCode",{parentName:"li"},"igb_uio")," driver:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"dpdk-devbind.py -b igb_uio 0000:8a:00.0\n")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},"Create 2 Virtual Functions (vfs) from the PF and bind them with ",(0,r.kt)("inlineCode",{parentName:"li"},"vfio-pci")," driver:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"echo 2 > /sys/bus/pci/devices/0000:8a:00.0/max_vfs\ndpdk-devbind.py -b vfio-pci 0000:8b:00.0\n")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},"Configure acc100 using the ",(0,r.kt)("inlineCode",{parentName:"li"},"pf-bb-config")," tool:\nThe Physical Function (PF) Baseband Device (BBDEV) Configuration Application (",(0,r.kt)("inlineCode",{parentName:"li"},"pf_bb_config"),") provides a means to configure a baseband device at the host level. The program accesses the configuration space and sets various parameters through memory-mapped I/O (MMIO) reads and writes.\nThe parameters are parsed from a given configuration file (with .cfg extensions) that is specific to a particular baseband device, although they follow same format.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"For more information about the pf-bb-config tool, please refer to the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/intel/pf-bb-config"},"documentation"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"pf_bb_config ACC100 -c /opt/pf-bb-config/acc100_config_vf_5g.cfg\n\nTue Jun  6 10:49:20 2023:INFO:Queue Groups: 2 5GUL, 2 5GDL, 2 4GUL, 2 4GDL\nTue Jun  6 10:49:20 2023:INFO:Configuration in VF mode\nTue Jun  6 10:49:21 2023:INFO: ROM version MM 99AD92\nTue Jun  6 10:49:21 2023:WARN:* Note: Not on DDR PRQ version  1302020 != 10092020\nTue Jun  6 10:49:21 2023:INFO:PF ACC100 configuration complete\nTue Jun  6 10:49:21 2023:INFO:ACC100 PF [0000:8a:00.0] configuration complete!\n")),(0,r.kt)("ol",{start:6},(0,r.kt)("li",{parentName:"ol"},"Check the new VFs created are available and ready to be used by the FlexRan library:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"dpdk-devbind.py -s\n...\nBaseband devices using DPDK-compatible driver\n=============================================\n0000:8a:00.0 'Device 0d5c' drv=igb_uio unused=vfio-pci\n0000:8b:00.0 'Device 0d5d' drv=vfio-pci unused=igb_uio\n\nOther Baseband devices\n======================\n0000:8b:00.1 'Device 0d5d' unused=igb_uio,vfio-pci\n...\n")),(0,r.kt)("h3",{id:"dpdk-configuration"},"DPDK Configuration"),(0,r.kt)("p",null,"The Data Plane Development Kit (DPDK) is a set of data plane libraries and network interface controller drivers for fast packet processing. It is designed to run on any processors. In our case, we will use the DPDK libraries to accelerate the performance of the FlexRan library.\nLet's start to create some VFs to be available for the FlexRan workloads:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Create the VF PCI addresses in the node:")),(0,r.kt)("p",null,"In this section we will create 4 VFs for each PF (2 PFs in total for the dual port E810 100G interface) binding to the vfio driver, and then, we will assign a MAC address to each VF.\nThe MAC address is used by the FlexRan library to identify the VFs. This is not a mandatory step, but then, you will need to modify the FlexRan Docker entrypoint script in order to adapt the MAC addresses to the VFs created. We will talk more about the docker entrypoint script in the next section."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"echo 4 > /sys/bus/pci/devices/0000:51:00.0/sriov_numvfs\nip link set p2p1 vf 0 mac 00:11:22:33:00:00\nip link set p2p1 vf 1 mac 00:11:22:33:00:10\nip link set p2p1 vf 2 mac 00:11:22:33:00:20\nip link set p2p1 vf 3 mac 00:11:22:33:00:30\necho 4 > /sys/bus/pci/devices/0000:51:00.1/sriov_numvfs\nip link set p2p2 vf 0 mac 00:11:22:33:00:01\nip link set p2p2 vf 1 mac 00:11:22:33:00:11\nip link set p2p2 vf 2 mac 00:11:22:33:00:21\nip link set p2p2 vf 3 mac 00:11:22:33:00:31\ndpdk-devbind.py -b vfio-pci 0000:51:01.0 0000:51:01.1 0000:51:01.2 0000:51:01.3 0000:51:11.0 0000:51:11.1 0000:51:11.2 0000:51:11.3\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Review the configuration:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"dpdk-devbind.py -s\n\nNetwork devices using DPDK-compatible driver\n============================================\n0000:51:01.0 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n0000:51:01.1 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n0000:51:01.2 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n0000:51:01.3 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n0000:51:01.0 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n0000:51:11.1 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n0000:51:21.2 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n0000:51:31.3 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n\nNetwork devices using kernel driver\n===================================\n0000:19:00.0 'BCM57504 NetXtreme-E 10Gb/25Gb/40Gb/50Gb/100Gb/200Gb Ethernet 1751' if=em1 drv=bnxt_en unused=igb_uio,vfio-pci *Active*\n0000:19:00.1 'BCM57504 NetXtreme-E 10Gb/25Gb/40Gb/50Gb/100Gb/200Gb Ethernet 1751' if=em2 drv=bnxt_en unused=igb_uio,vfio-pci\n0000:19:00.2 'BCM57504 NetXtreme-E 10Gb/25Gb/40Gb/50Gb/100Gb/200Gb Ethernet 1751' if=em3 drv=bnxt_en unused=igb_uio,vfio-pci\n0000:19:00.3 'BCM57504 NetXtreme-E 10Gb/25Gb/40Gb/50Gb/100Gb/200Gb Ethernet 1751' if=em4 drv=bnxt_en unused=igb_uio,vfio-pci\n0000:51:00.0 'Ethernet Controller E810-C for QSFP 1592' if=eth13 drv=ice unused=igb_uio,vfio-pci\n0000:51:00.1 'Ethernet Controller E810-C for QSFP 1592' if=rename8 drv=ice unused=igb_uio,vfio-pci\n\nBaseband devices using DPDK-compatible driver\n=============================================\n0000:8a:00.0 'Device 0d5c' drv=igb_uio unused=vfio-pci\n0000:8b:00.0 'Device 0d5d' drv=vfio-pci unused=igb_uio\n\nOther Baseband devices\n======================\n0000:8b:00.1 'Device 0d5d' unused=igb_uio,vfio-pci\n\n")),(0,r.kt)("h3",{id:"sriov-configuration"},"SRIOV Configuration"),(0,r.kt)("p",null,"The Single Root I/O Virtualization ",(0,r.kt)("inlineCode",{parentName:"p"},"SR-IOV")," is a specification that allows a PCIe device to appear to be multiple separate physical PCIe devices.\nThe SR-IOV network device plugin is Kubernetes device plugin for discovering and advertising networking resources such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"SR-IOV virtual functions ",(0,r.kt)("inlineCode",{parentName:"li"},"VFs")),(0,r.kt)("li",{parentName:"ul"},"PCI physical functions ",(0,r.kt)("inlineCode",{parentName:"li"},"PFs")),(0,r.kt)("li",{parentName:"ul"},"Auxiliary network devices, in particular Subfunctions ",(0,r.kt)("inlineCode",{parentName:"li"},"SFs"))),(0,r.kt)("p",null,"To deploy workloads with SR-IOV VF, Auxiliary network devices or PCI PF, this plugin needs to work together with the following two CNI components:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Any CNI meta plugin supporting Device Plugin based network provisioning. In our case will be ",(0,r.kt)("inlineCode",{parentName:"li"},"Multus")),(0,r.kt)("li",{parentName:"ul"},"A CNI capable of consuming the network device allocated to the Pod")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"For more information about the SR-IOV CNI, please refer to the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/k8snetworkplumbingwg/sriov-network-device-plugin/tree/master"},"documentation"))),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Prepare the config map for the device plugin:")),(0,r.kt)("p",null,"You could get the information to fill the config map from the ",(0,r.kt)("inlineCode",{parentName:"p"},"lspci")," command. In our case we will have the next 3 types of devices:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"FEC acceleartor card VF: ",(0,r.kt)("inlineCode",{parentName:"p"},"0d5d"),".\nThis is the first VF created on the ACC100 card and should match with the first VF created on the previous section.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"ODU interface: ",(0,r.kt)("inlineCode",{parentName:"p"},"1889"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"8086")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"p2p1")," as a filter.\nThis is the first port of the E810 interface and should match with the 4 first VFs created on the previous section.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"ORU interface: ",(0,r.kt)("inlineCode",{parentName:"p"},"1889"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"8086")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"p2p2")," as a filter.\nThis is the second port of the E810 interface and should match with the 4 last VFs created on the previous section."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'cat <<EOF | k apply -f -\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: sriovdp-config\n  namespace: kube-system\ndata:\n  config.json: |\n    {\n        "resourceList": [\n            {\n                "resourceName": "intel_fec_5g",\n                "devicetype": "accelerator",\n                "selectors": {\n                    "vendors": ["8086"],\n                    "devices": ["0d5d"]\n                }\n            },\n            {\n                "resourceName": "intel_sriov_odu",\n                "selectors": {\n                    "vendors": ["8086"],\n                    "devices": ["1889"],\n                    "drivers": ["vfio-pci"],\n                    "pfNames": ["p2p1"]\n                }\n            },\n            {\n                "resourceName": "intel_sriov_oru",\n                "selectors": {\n                    "vendors": ["8086"],\n                    "devices": ["1889"],\n                    "drivers": ["vfio-pci"],\n                    "pfNames": ["p2p2"]\n                }\n            }\n        ]\n    }\nEOF\n')),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Prepare the daemonset for the device plugin")),(0,r.kt)("p",null,"No changes are needed in the daemonset, so you can use the same upstream daemonset as is for the FlexRAN deployment."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"For more information about the daemonset, please refer to the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/k8snetworkplumbingwg/sriov-network-device-plugin/blob/master/deployments/sriovdp-daemonset.yaml"},"documentation"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'cat <<EOF | k apply -f -\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: sriov-device-plugin\n  namespace: kube-system\n\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: kube-sriov-device-plugin-amd64\n  namespace: kube-system\n  labels:\n    tier: node\n    app: sriovdp\nspec:\n  selector:\n    matchLabels:\n      name: sriov-device-plugin\n  template:\n    metadata:\n      labels:\n        name: sriov-device-plugin\n        tier: node\n        app: sriovdp\n    spec:\n      hostNetwork: true\n      nodeSelector:\n        kubernetes.io/arch: amd64\n      tolerations:\n      - key: node-role.kubernetes.io/master\n        operator: Exists\n        effect: NoSchedule\n      serviceAccountName: sriov-device-plugin\n      containers:\n      - name: kube-sriovdp\n        image: ghcr.io/k8snetworkplumbingwg/sriov-network-device-plugin:latest-amd64\n        imagePullPolicy: IfNotPresent\n        args:\n        - --log-dir=sriovdp\n        - --log-level=10\n        securityContext:\n          privileged: true\n        resources:\n          requests:\n            cpu: "250m"\n            memory: "40Mi"\n          limits:\n            cpu: 1\n            memory: "200Mi"\n        volumeMounts:\n        - name: devicesock\n          mountPath: /var/lib/kubelet/\n          readOnly: false\n        - name: log\n          mountPath: /var/log\n        - name: config-volume\n          mountPath: /etc/pcidp\n        - name: device-info\n          mountPath: /var/run/k8s.cni.cncf.io/devinfo/dp\n      volumes:\n        - name: devicesock\n          hostPath:\n            path: /var/lib/kubelet/\n        - name: log\n          hostPath:\n            path: /var/log\n        - name: device-info\n          hostPath:\n            path: /var/run/k8s.cni.cncf.io/devinfo/dp\n            type: DirectoryOrCreate\n        - name: config-volume\n          configMap:\n            name: sriovdp-config\n            items:\n            - key: config.json\n              path: config.json\nEOF\n')),(0,r.kt)("p",null,"After deploying the daemonset on the RKE2 edge cluster, you should see the pods running:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"$ kubectl get pods -n kube-system | grep sriov\nkube-system       kube-sriov-device-plugin-amd64-twjfl                    1/1     Running   0          2m\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Check the interfaces discovered and available in the node for the FlexRan workload:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'$ kubectl get $(kubectl get nodes -oname) -o jsonpath=\'{.status.allocatable}\' | jq\n{\n  "cpu": "64",\n  "ephemeral-storage": "256196109726",\n  "hugepages-1Gi": "40Gi",\n  "hugepages-2Mi": "0",\n  "intel.com/intel_fec_5g": "1",\n  "intel.com/intel_sriov_odu": "4",\n  "intel.com/intel_sriov_oru": "4",\n  "memory": "221396384Ki",\n  "pods": "110"\n}\n')),(0,r.kt)("p",null,"As you can see in the output above, we have 2 types of resources available for the FlexRan workload:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The FEC will be ",(0,r.kt)("inlineCode",{parentName:"p"},"intel.com/intel_fec_5g")," and the value will be 1 because we bind just only 1 of 2.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The VFs will be ",(0,r.kt)("inlineCode",{parentName:"p"},"intel.com/intel_sriov_odu")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"intel.com/intel_sriov_oru")," and the value will be 4 because we bind 4 VFs for each PF. "))),(0,r.kt)("p",null,"Basically, FlexRan will request some resources available in the host to be used as a VF for the tests we're going to run."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Important Note: If you don't get the resources available here, does not make sense continue with the flexran demo tests. Please, review the previous steps to ensure you have the VFs created and the SRIOV CNI plugin working properly.")),(0,r.kt)("h2",{id:"flexran-tests"},"FlexRan tests"),(0,r.kt)("h3",{id:"references"},"References"),(0,r.kt)("p",null,"For this article, we will use the next references to deploy the Intel FlexRan reference implementation on top of the ATIP edge cluster:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We will use the pre-defined containers from Intel: ",(0,r.kt)("a",{parentName:"li",href:"https://hub.docker.com/r/intel/flexran_vdu"},"FlexRan pre-defined containers")),(0,r.kt)("li",{parentName:"ul"},"You will also need to download the FlexRan-22.07 tarball from Intel to run the tests and mount the downloaded ",(0,r.kt)("inlineCode",{parentName:"li"},"tests")," folder into the pre-defined containers because it's not included into the pre-defined containers. ",(0,r.kt)("blockquote",{parentName:"li"},(0,r.kt)("p",{parentName:"blockquote"},"In order to download those files, it is required to have access to the Intel website (you can ask your Intel representative). "),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},"FlexRAN-22.07-L1.tar.gz_part00"),(0,r.kt)("li",{parentName:"ul"},"FlexRAN-22.07-L1.tar.gz_part01")))),(0,r.kt)("li",{parentName:"ul"},"Container Entrypoint script (Just in case you need to change anything else like the MAC addresses for the VFs)")),(0,r.kt)("h3",{id:"prepare-the-files-downloaded-from-intel"},"Prepare the files downloaded from Intel"),(0,r.kt)("p",null,"Once you have the tarball files downloaded from Intel, you can join the files and extract the content:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"mkdir flexran; \ncp FlexRAN-22.07-L1.tar.gz_part* flexran; \ncd flexran\ncat FlexRAN-22.07-L1.tar.gz_part* | tar -xzvf -\n")),(0,r.kt)("p",null,"Now, we need to execute the ",(0,r.kt)("inlineCode",{parentName:"p"},"extract.sh")," script to get the ",(0,r.kt)("inlineCode",{parentName:"p"},"tests")," folder available to be mounted into the containers. Also, we will copy the docker entrypoint script to be modified if needed."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"During this process manual intervention is required to accept the license agreement")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"./extract.sh\nmkdir /home/tmp_flexran\ncp -R tests/ /home/tmp_flexran/\ncp  build/docker/docker_entry.sh /home/tmp_flexran/\n")),(0,r.kt)("p",null,"The `/home/tmp_flexran will be the folder to be mounted into the containers on the next section."),(0,r.kt)("p",null,"Before deploying the FlexRan containers, let's review the next steps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Interfaces to be used in the flexran pods yaml files, should be referenced by their resource names. You could get those as: ",(0,r.kt)("inlineCode",{parentName:"li"},"kubectl get nodes -o json | jq '.items[].status.allocatable'")," as explained in the previous ",(0,r.kt)("a",{parentName:"li",href:"#sriov-configuration"},"section")),(0,r.kt)("li",{parentName:"ul"},"The container entrypoint script contains the tests files customization for this specific environment. It will modify some parameters such as MAC addresses, ",(0,r.kt)("inlineCode",{parentName:"li"},"VF")," information and the ",(0,r.kt)("inlineCode",{parentName:"li"},"dpdk")," info into the ",(0,r.kt)("inlineCode",{parentName:"li"},"tests"),". It will be explained in the next section."),(0,r.kt)("li",{parentName:"ul"},"Tests should be mounted in ",(0,r.kt)("inlineCode",{parentName:"li"},"/home/tmp_flexran/tests")," and exposed in ",(0,r.kt)("inlineCode",{parentName:"li"},"/home/flexran/tests"))),(0,r.kt)("h3",{id:"container-entrypoint"},"Container entrypoint"),(0,r.kt)("p",null,"The FlexRan containers run a script when the container is started.\nThe script will modify the configuration files of the FlexRan tests applications to adapt the tests to our environment."),(0,r.kt)("p",null,"The modifications done in this file will be:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"PCIDEVICE_INTEL_COM_INTEL_FEC_5G=$(env|grep PCIDEVICE_INTEL_COM_INTEL_FEC_5G= |awk -F '=' '{print $2}')"),"  in order to select the right PCI device for the FEC ACC100 card used for the 5G acceleration.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"export INTEL_COM_INTEL_CPULIST=$(cat /sys/fs/cgroup/cpuset/cpuset.cpus)")," to get the CPU list of the host machine."))),(0,r.kt)("p",null,"Also, we need to change the CPU cores as well as the MAC addresses into the RU section because there isn't any substitution in the entrypoint script. We need to change the next lines:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'    sed -i "s/ioCore=2/ioCore=62/g" config_file_o_ru.dat\n    sed -i "s/duMac0=[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]/duMac0=00:11:22:33:00:00/g" config_file_o_ru.dat\n    sed -i "s/duMac1=[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]/duMac1=00:11:22:33:00:10/g" config_file_o_ru.dat\n    sed -i "s/ruMac0=[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]/ruMac0=00:11:22:33:00:01/g" config_file_o_ru.dat\n    sed -i "s/ruMac1=[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]/ruMac1=00:11:22:33:00:11/g" config_file_o_ru.dat\n    \n    sed -i "s/duMac2=[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]/duMac2=00:11:22:33:00:20/g" config_file_o_ru.dat\n    sed -i "s/duMac3=[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]/duMac3=00:11:22:33:00:30/g" config_file_o_ru.dat\n    sed -i "s/ruMac2=[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]/ruMac2=00:11:22:33:00:21/g" config_file_o_ru.dat\n    sed -i "s/ruMac3=[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]:[0-9,a-z][0-9,a-z]/ruMac3=00:11:22:33:00:31/g" config_file_o_ru.dat\n')),(0,r.kt)("p",null,"Then, we need to remove (or comment with the hashtag ",(0,r.kt)("inlineCode",{parentName:"p"},"#")," sign) the tests not covered by the flexran container version we are using (the test files are not present in the FlexRan tests suite used so the script will fail):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"flexran/bin/nr5g/gnb/l1/orancfg/sub3_mu0_20mhz_sub3_mu1_20mhz_4x4/gnb/"),(0,r.kt)("li",{parentName:"ul"},"flexran/bin/nr5g/gnb/l1/orancfg/sub3_mu0_20mhz_sub6_mu1_100mhz_4x4/gnb/"),(0,r.kt)("li",{parentName:"ul"},"flexran/bin/nr5g/gnb/l1/orancfg/mmwave_mu3_100mhz_2x2/gnb/"),(0,r.kt)("li",{parentName:"ul"},"flexran/bin/nr5g/gnb/l1/orancfg/mmwave_mu3_100mhz_2x2/gnb/"),(0,r.kt)("li",{parentName:"ul"},"flexran/bin/nr5g/gnb/l1/orancfg/sub3_mu0_20mhz_sub3_mu1_20mhz_4x4/oru/"),(0,r.kt)("li",{parentName:"ul"},"flexran/bin/nr5g/gnb/l1/orancfg/sub3_mu0_20mhz_sub6_mu1_100mhz_4x4/oru/"),(0,r.kt)("li",{parentName:"ul"},"flexran/bin/nr5g/gnb/l1/orancfg/mmwave_mu3_100mhz_2x2/oru/")),(0,r.kt)("p",null,"For instance, you will have the next block commented (or removed):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},'#cd /home/flexran/bin/nr5g/gnb/l1/orancfg/sub3_mu0_20mhz_sub3_mu1_20mhz_4x4/gnb/\n#sed -i "s/<systemThread>2, 0, 0<\\/systemThread>/<systemThread>$systemthread, 0, 0<\\/systemThread>/g" phycfg_xran.xml\n#sed -i "s/<timerThread>0, 96, 0<\\/timerThread>/<timerThread>$timerThread, 96, 0<\\/timerThread>/g" phycfg_xran.xml\n#sed -i "s/<FpgaDriverCpuInfo>3, 96, 0<\\/FpgaDriverCpuInfo>/<FpgaDriverCpuInfo>$FpgaDriverCpuInfo, 96, 0<\\/FpgaDriverCpuInfo>/g" phycfg_xran.xml\n#sed -i "s/<FrontHaulCpuInfo>3, 96, 0<\\/FrontHaulCpuInfo>/<FrontHaulCpuInfo>$FrontHaulCpuInfo, 96, 0<\\/FrontHaulCpuInfo>/g" phycfg_xran.xml\n#sed -i "s/<radioDpdkMaster>2, 99, 0<\\/radioDpdkMaster>/<radioDpdkMaster>$radioDpdkMaster, 99, 0<\\/radioDpdkMaster>/g" phycfg_xran.xml\n')),(0,r.kt)("p",null,"An example of docker entrypoint script is available ",(0,r.kt)("a",{target:"_blank",href:n(2383).Z},"here")),(0,r.kt)("h3",{id:"flexran-timer-mode"},"FlexRan Timer Mode"),(0,r.kt)("p",null,"FlexRAN Timer Mode use case does not use fronthaul. RF IQ samples are read from files and write to files. The test pod is configured with two containers. One container is for ",(0,r.kt)("inlineCode",{parentName:"p"},"L1APP"),", and another one is for ",(0,r.kt)("inlineCode",{parentName:"p"},"TestMAC"),".\nSmaller storage is built in pod as Kubernetes resources, but the storage is not enough for the test case. The test case requires 20GB storage for tests files, so it will be mounted from the host using the ",(0,r.kt)("inlineCode",{parentName:"p"},"tests")," volume mount path.\nThe test case is a setup for one peak cell and two average cells. 8 cores with HT enabled are pinned for ",(0,r.kt)("inlineCode",{parentName:"p"},"L1APP"),", the average core utilization is between 45-65%. The below figure shows the threading model for this test case."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"img.png",src:n(8971).Z,width:"829",height:"508"})),(0,r.kt)("p",null,"To deploy the Test Timer Mode, we will use the next yaml file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'cat <<EOF | kubectl apply -f - \napiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    app: flexran-dockerimage_release\n  name: flexran-dockerimage-release\nspec:\n  containers:\n  - securityContext:\n      privileged: false\n      capabilities:\n        add:\n          - IPC_LOCK\n          - SYS_NICE\n    command: [ "/bin/bash", "-c", "--" ]\n    args: [" cp flexran/build/docker/docker_entry.sh .; sh docker_entry.sh -m timer ; cd /home/flexran/bin/nr5g/gnb/l1/; ./l1.sh -e ; top"]\n    tty: true\n    stdin: true\n    env:\n    - name: LD_LIBRARY_PATH\n      value: /opt/oneapi/lib/intel64\n    image: intel/flexran_vdu:v22.07\n    name: flexran-l1app\n    resources:\n      requests:\n        memory: "32Gi"\n        intel.com/intel_fec_5g: \'1\'\n        hugepages-1Gi: 16Gi\n      limits:\n        memory: "32Gi"\n        intel.com/intel_fec_5g: \'1\'\n        hugepages-1Gi: 16Gi\n    volumeMounts:\n    - name: hugepage\n      mountPath: /hugepages\n    - name: varrun\n      mountPath: /var/run/dpdk\n      readOnly: false\n    - name: tests\n      mountPath: /home/flexran/tests\n      readOnly: false\n    - name: proc\n      mountPath: /proc\n      readOnly: false\n  - securityContext:\n      privileged: false\n      capabilities:\n        add:\n          - IPC_LOCK\n          - SYS_NICE\n    command: [ "/bin/bash", "-c", "--" ]\n    args: ["sleep 10; sh docker_entry.sh -m timer ; cd /home/flexran/bin/nr5g/gnb/testmac/; ./l2.sh --testfile=icelake-sp/icxsp.cfg; top"]\n    tty: true\n    stdin: true\n    env:\n    - name: LD_LIBRARY_PATH\n      value: /opt/oneapi/lib/intel64\n    image: intel/flexran_vdu:v22.07\n    name: flexran-testmac\n    resources:\n      requests:\n        memory: "12Gi"\n        hugepages-1Gi: 8Gi\n      limits:\n        memory: "12Gi"\n        hugepages-1Gi: 8Gi\n    volumeMounts:\n    - name: hugepage\n      mountPath: /hugepages\n    - name: varrun\n      mountPath: /var/run/dpdk\n      readOnly: false\n    - name: tests\n      mountPath: /home/flexran/tests\n      readOnly: false\n    - name: proc\n      mountPath: /proc\n      readOnly: false  \n  volumes:\n  - name: hugepage\n    emptyDir:\n      medium: HugePages\n  - name: varrun\n    emptyDir: {}\n  - name: tests\n    hostPath:\n      path: "/home/tmp_flexran/tests"\n  - name: proc\n    hostPath:\n      path: /proc    \nEOF\n')),(0,r.kt)("p",null,"The next resources are required:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"intel.com/intel_fec_5g: '1'")," to request the FEC ACC100 resource."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"hugepages-1Gi: 16Gi")," to request the hugepages resource for the first container."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"hugepages-1Gi: 8Gi")," to request the hugepages resource for the second container."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/home/tmp_flexran/tests")," folder mounted to ",(0,r.kt)("inlineCode",{parentName:"li"},"/home/flexran/tests")," in order to have the tests available for the containers."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"image: intel/flexran_vdu:v22.07")," to use the pre-defined container from Intel pre-defined containers.")),(0,r.kt)("p",null,"Once the pod is deployed, you can check the status of the pod:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl get pods\nNAME                        READY   STATUS    RESTARTS   AGE\nflexran-dockerimage-release   2/2     Running   0          2m\n")),(0,r.kt)("p",null,"This will launch automatically the Timer Mode Tests which contains 83 tests for the FlexRan library. It could take up to 3 hours to complete the tests. The status of the tests can be found in the container logs:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl logs flexran-dockerimage-release flexran-l1app\n")),(0,r.kt)("p",null,"After a successful tests execution the following output should be shown:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"All Tests Completed, Total run 83 Tests, PASS 83 Tests, and FAIL 0 Tests\n----------------------------------------------------------------------------\nmem_mgr_display_size:\n    Num Memory Alloc:               11\n    Total Memory Size:         264,018\n----------------------------------------------------------------------------\n")),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"htop")," we could see the CPU usage of the containers as well as the pinned cores for this workload:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"img_1.png",src:n(1095).Z,width:"1736",height:"980"})),(0,r.kt)("p",null,"Using the Rancher UI, you can check the status of the pods and the logs of the containers.\nAlso, you could get the next metrics using prometheus and grafana to check the CPU usage , CPU cores isolated used, and the Memory usage of the containers:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"img_6.png",src:n(8695).Z,width:"1915",height:"895"})),(0,r.kt)("h3",{id:"flexran-xran-mode"},"FlexRan Xran Mode"),(0,r.kt)("p",null,"FlexRAN XRAN Mode uses two Intel\xae Ethernet 100G 2P E810 Adapter on the two PCIe x16 slots. The two NIC cards are connected by fiber directly for fronthaul eCPRI C-Plane and U-Plane traffic.\nSR-IOV is enabled on the two E810 NIC cards. ACC100 accelerator cards and RF IQ samples over Ethernet VFs use SR-IOV resources. The O-DU test pod is configured with two containers. One container is for ",(0,r.kt)("inlineCode",{parentName:"p"},"L1APP"),", and another one is for ",(0,r.kt)("inlineCode",{parentName:"p"},"TestMAC"),". The O-RU test pod is configured with one container.\nSmaller storage is built in pod as Kubernetes resources, but the larger storage is mapped from the host.\nThe test case is a setup for six average cells with O-RAN lower layer split option 7-2x. 2 cores with HT enabled are pinned for ",(0,r.kt)("inlineCode",{parentName:"p"},"L1APP"),", the average core utilization is 65%. 2 cores are pinned for O-RU fronthaul, 2 cores are pinned for L1 fronthaul. The below figure shows the threading model for this test case."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"img.png",src:n(9870).Z,width:"834",height:"518"})),(0,r.kt)("p",null,"To deploy the XRAN Mode, we will use the next yaml file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'cat <<EOF | kubectl apply -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: flexran-vdu\n  name: flexran-vdu\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: flexran-vdu\n  template:\n    metadata:\n      labels:\n        app: flexran-vdu\n    spec:\n      containers:\n      - securityContext:\n          privileged: true\n          capabilities:\n            add:\n              - IPC_LOCK\n              - SYS_NICE\n        command: [ "/bin/bash", "-c", "--" ]\n        args: [ "cp flexran/build/docker/docker_entry.sh . ; sh docker_entry.sh -m xran ; top"]\n        tty: true\n        stdin: true\n        env:\n         - name: LD_LIBRARY_PATH\n           value: /opt/oneapi/lib/intel64\n        image: intel/flexran_vdu:v22.07\n        name: flexran-vdu\n        resources:\n          requests:\n            memory: "24Gi"\n            hugepages-1Gi: 20Gi\n            intel.com/intel_fec_5g: \'1\'\n            intel.com/intel_sriov_odu: \'4\'\n          limits:\n            memory: "24Gi"\n            hugepages-1Gi: 20Gi\n            intel.com/intel_fec_5g: \'1\'\n            intel.com/intel_sriov_odu: \'4\'\n        volumeMounts:\n        - name: hugepage\n          mountPath: /hugepages\n        - name: varrun\n          mountPath: /var/run/dpdk\n          readOnly: false\n        - name: tests\n          mountPath: /home/flexran/tests\n          readOnly: false\n        - name: proc\n          mountPath: /proc\n          readOnly: false\n      volumes:\n      - name: hugepage\n        emptyDir:\n          medium: HugePages\n      - name: varrun\n        emptyDir: {}\n      - name: tests\n        hostPath:\n          path: "/home/tmp_flexran/tests"\n      - name: proc\n        hostPath:\n          path: /proc\n---\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: flexran-vru\n  name: flexran-vru\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: flexran-vru\n  template:\n    metadata:\n      labels:\n        app: flexran-vru\n    spec:\n      containers:\n      - securityContext:\n          privileged: true\n          capabilities:\n            add:\n              - IPC_LOCK\n              - SYS_NICE\n        command: [ "/bin/bash", "-c", "--" ]\n        args: ["cp flexran/build/docker/docker_entry.sh . ; sh docker_entry.sh -m xran ; top"]\n        tty: true\n        stdin: true\n        env:\n         - name: LD_LIBRARY_PATH\n           value: /opt/oneapi/lib/intel64\n        image: intel/flexran_vdu:v22.07\n        name: flexran-oru\n        resources:\n          requests:\n            memory: "24Gi"\n            hugepages-1Gi: 16Gi\n            intel.com/intel_sriov_oru: \'4\'\n          limits:\n            memory: "24Gi"\n            hugepages-1Gi: 16Gi\n            intel.com/intel_sriov_oru: \'4\'\n        volumeMounts:\n        - name: hugepage\n          mountPath: /hugepages\n        - name: varrun\n          mountPath: /var/run/dpdk\n          readOnly: false\n        - name: tests\n          mountPath: /home/flexran/tests\n          readOnly: false\n        - name: proc\n          mountPath: /proc\n          readOnly: false\n      volumes:\n      - name: hugepage\n        emptyDir:\n          medium: HugePages\n      - name: varrun\n        emptyDir: {}\n      - name: tests\n        hostPath:\n          path: "/home/tmp_flexran/tests"\n      - name: proc\n        hostPath:\n          path: /proc\n\nEOF  \n')),(0,r.kt)("p",null,"The next resources are required:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"intel.com/intel_fec_5g: '1'")," to request the FEC ACC100 resource."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"intel.com/intel_sriov_odu: '4'")," to request the 4 VFs for the ODU interface."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"intel.com/intel_sriov_oru: '4'")," to request the 4 VFs for the ORU interface."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"hugepages-1Gi: 20Gi")," to request the hugepages resource for the first container."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"hugepages-1Gi: 16Gi")," to request the hugepages resource for the second container."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/home/tmp_flexran/tests")," folder mounted to ",(0,r.kt)("inlineCode",{parentName:"li"},"/home/flexran/tests")," in order to have the tests available for the containers.")),(0,r.kt)("p",null,"Once the pods are deployed, you need to launch the tests manually. You can do that using the next commands:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Open a terminal in the ",(0,r.kt)("inlineCode",{parentName:"li"},"flexran-vdu")," pod and run the following commands:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl exec -ti flexran-vdu-66c9bf5765-ftptg /bin/bash\n\ncd flexran/bin/nr5g/gnb/l1/orancfg/sub6_mu1_100mhz_4x4/gnb/\n./l1.sh -oru\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Open a new terminal in the ",(0,r.kt)("inlineCode",{parentName:"li"},"flexran-vdu")," pod and run the following commands:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl exec -ti flexran-vdu-66c9bf5765-ftptg /bin/bash\n\ncd flexran/bin/nr5g/gnb/testmac\n./l2.sh --testfile=../l1/orancfg/sub6_mu1_100mhz_4x4/gnb/testmac_clxsp_mu1_100mhz_hton_oru.cfg\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Open a third terminal to run the ",(0,r.kt)("inlineCode",{parentName:"li"},"flexran-vru")," pod and run the following commands:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl exec -ti flexran-vru-66casd2e5765-23resd /bin/bash\n\ncd flexran/bin/nr5g/gnb/l1/orancfg/sub6_mu1_100mhz_4x4/oru/\nchmod +x run_o_ru.sh; taskset -c 20 ./run_o_ru.sh\n")),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"htop")," we could see the CPU usage of the containers as well as the pinned cores for this workload:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"img_2.png",src:n(3587).Z,width:"1649",height:"957"})),(0,r.kt)("p",null,"Using the Rancher UI, you can check the status of the pods and the logs of the containers.\nAlso, you could get the next metrics using prometheus and grafana to check the CPU usage , CPU cores isolated used, and the Memory usage of the containers:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"img_3.png",src:n(8418).Z,width:"1843",height:"895"})),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"Building, testing, and deploying a properly configured Intel\xae FlexRAN implementation can show the benefits of VNFs and vRAN with Intel\xae Xeon\xae Scalable Processors and Intel\xae Advanced Vector Extensions.\nSUSE provides all the components for an open-source, enterprise-grade, software-defined stack for cloud-native orchestration and management. SUSE Linux Enterprise Micro Real Time, Rancher Kubernetes Engine v2 (RKE2) and Rancher Management were used and illustrated as key ingredients to simplify the deployment of Intel\xae FlexRAN."))}c.isMDXComponent=!0},4379:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/dependencies.tar-6670dd24286eab1ff44ae4f2ecc1d518.gz"},2383:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/flexran-dockerentrypoint-770e638dbcb42ca500952a2c633ffef6.sh"},8181:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/system-config-cc951c914ab7ef2227ff55e08e2b9f2b.xml"},9354:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/architecture-components-6da738ff8243400b53fa1440e05c94c0.png"},1095:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/clitimer-d26bc93c94a3cfb22169d70c2ab4dc7c.png"},3113:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/edge-06988c351b0dc0022d4cadfb3f3f9345.png"},8695:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/graftimer-42e13bd519d9a0b4a3b53a86e839d425.png"},9298:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/import-bios-dc8ab5db57feda5794f47efb142ab95c.png"},7154:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/mgmt-component-58c05bd0acbb4b5d73bff46fc72eac01.png"},8971:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/timer3-354caf268444b9625389c617ceff6996.png"},9870:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/xran1-a7fde60e2ae5cb2cf65eebd8282584f4.png"},3587:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/xran2-0ce802ee2c7d5c6b4321ef4fa513df48.png"},8418:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/xran3-5ee9949853787eba22afd5b0741beba4.png"}}]);