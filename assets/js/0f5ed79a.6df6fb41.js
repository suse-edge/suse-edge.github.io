"use strict";(self.webpackChunksuse_edge_docs=self.webpackChunksuse_edge_docs||[]).push([[2278],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(n),m=r,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||o;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:r,i[1]=l;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8646:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:6,title:"*Draft* Feature Configuration"},i="SUSE Adaptive Telco Infrastructure Platform (ATIP)",l={unversionedId:"product/atip/features",id:"product/atip/features",title:"*Draft* Feature Configuration",description:"SUSE ATIP is a platform designed for hosting modern, cloud native, Telco applications at scale from core to edge.",source:"@site/docs/product/atip/features.md",sourceDirName:"product/atip",slug:"/product/atip/features",permalink:"/docs/product/atip/features",draft:!1,editUrl:"https://github.com/suse-edge/suse-edge.github.io/tree/main/docs/product/atip/features.md",tags:[],version:"current",lastUpdatedBy:"Alberto Morgante Medina",lastUpdatedAt:1690382815,formattedLastUpdatedAt:"Jul 26, 2023",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"*Draft* Feature Configuration"},sidebar:"docs",previous:{title:"*Draft* Edge Site Installation",permalink:"/docs/product/atip/edge-site"},next:{title:"*Draft* Lifecycle Actions",permalink:"/docs/product/atip/lifecycle"}},s={},u=[{value:"Bios configuration",id:"bios-configuration",level:2},{value:"Kernel Real Time",id:"kernel-real-time",level:2},{value:"CPU Tuned Configuration",id:"cpu-tuned-configuration",level:2},{value:"Multus + Calico",id:"multus--calico",level:2},{value:"SRIOV",id:"sriov",level:2},{value:"Option 1 - Installation of SR-IOV CNI device plugins and a config map to configure it properly",id:"option-1---installation-of-sr-iov-cni-device-plugins-and-a-config-map-to-configure-it-properly",level:3},{value:"Prepare the config map for the device plugin",id:"prepare-the-config-map-for-the-device-plugin",level:4},{value:"Prepare the daemonset for the device plugin",id:"prepare-the-daemonset-for-the-device-plugin",level:4},{value:"Option 2 - Installation using Rancher using Helm chart for SR-IOV CNI and device plugins",id:"option-2---installation-using-rancher-using-helm-chart-for-sr-iov-cni-and-device-plugins",level:3},{value:"Get helm if not present",id:"get-helm-if-not-present",level:4},{value:"Install SRIOV",id:"install-sriov",level:4},{value:"Check the  deployed resources crd and pods",id:"check-the--deployed-resources-crd-and-pods",level:4},{value:"Check the label in the nodes",id:"check-the-label-in-the-nodes",level:4},{value:"Review the daemonset to see the new <code>sriov-network-config-daemon</code> and <code>sriov-rancher-nfd-worker</code> as active and ready",id:"review-the-daemonset-to-see-the-new-sriov-network-config-daemon-and-sriov-rancher-nfd-worker-as-active-and-ready",level:4},{value:"Check the interfaces detected",id:"check-the-interfaces-detected",level:4},{value:"Create the NetworkNode Policy to configure the VFs",id:"create-the-networknode-policy-to-configure-the-vfs",level:4},{value:"Validate configurations",id:"validate-configurations",level:4},{value:"Create the sriov network (Optional, in case we need a different network):",id:"create-the-sriov-network-optional-in-case-we-need-a-different-network",level:4},{value:"DPDK",id:"dpdk",level:2},{value:"Kernel parameters",id:"kernel-parameters",level:3},{value:"Load vfio-pci kernel module",id:"load-vfio-pci-kernel-module",level:3},{value:"Create VFs from the NICs",id:"create-vfs-from-the-nics",level:3},{value:"Bind the new VFs with the vfio-pci driver",id:"bind-the-new-vfs-with-the-vfio-pci-driver",level:3},{value:"Review the configuration applied:",id:"review-the-configuration-applied",level:3},{value:"Huge Pages",id:"huge-pages",level:2},{value:"Kernel parameters",id:"kernel-parameters-1",level:3},{value:"Usage of huge pages",id:"usage-of-huge-pages",level:3},{value:"CPU Pinning Configuration",id:"cpu-pinning-configuration",level:2},{value:"Requirements",id:"requirements",level:3},{value:"Use CPU Pinning on kubernetes",id:"use-cpu-pinning-on-kubernetes",level:3},{value:"NUMA Aware scheduling",id:"numa-aware-scheduling",level:2},{value:"Identify NUMA nodes",id:"identify-numa-nodes",level:3},{value:"VRAN Acceleration (Intel ACC100)",id:"vran-acceleration-intel-acc100",level:2},{value:"Kernel parameters",id:"kernel-parameters-2",level:3},{value:"Load igb_uio and vfio-pci kernel modules",id:"load-igb_uio-and-vfio-pci-kernel-modules",level:3},{value:"Get interface information Acc100",id:"get-interface-information-acc100",level:3},{value:"Bind the PF with igb_uio module",id:"bind-the-pf-with-igb_uio-module",level:3},{value:"Create the VFs from the PF",id:"create-the-vfs-from-the-pf",level:3},{value:"Configure acc100 with the proposed configuration file",id:"configure-acc100-with-the-proposed-configuration-file",level:3},{value:"Check the new VFs created from the FEC PF:",id:"check-the-new-vfs-created-from-the-fec-pf",level:3},{value:"Metal LB (Beta)",id:"metal-lb-beta",level:2}],p={toc:u},c="wrapper";function d(e){let{components:t,...o}=e;return(0,r.kt)(c,(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"suse-adaptive-telco-infrastructure-platform-atip"},"SUSE Adaptive Telco Infrastructure Platform (ATIP)"),(0,r.kt)("p",null,"SUSE ATIP is a platform designed for hosting modern, cloud native, Telco applications at scale from core to edge. "),(0,r.kt)("p",null,"This section documents how to configuration telco specific features on ATIP deployed clusters"),(0,r.kt)("p",null,"We will cover the next topics:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#bios-configuration"},"Bios configuration"),": Bios configuration to be used by the real time kernel to optimize the performance in the hardware."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#kernel-image-for-real-time"},"Kernel image for Real Time"),": Kernel image to be used by the real time kernel."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#cpu-tuned-configuration"},"CPU Tuned configuration"),": Tuned configuration to be used by the real time kernel."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#multus--calico"},"Multus-Calico configuration"),": Multus configuration to be used by the kubernetes cluster."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#sriov"},"SRIOV configuration"),": SRIOV configuration to be used by the kubernetes workloads."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#dpdk"},"DPDK configuration"),": DPDK configuration to be used by system."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#huge-pages"},"Huge Pages"),": Huge Pages configuration to be used by the kubernetes workloads."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#cpu-pinning-configuration"},"CPU Pinning configuration"),": CPU Pinning configuration to be used by the kubernetes workloads."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#numa-aware-scheduling"},"NUMA Aware scheduling configuration"),": NUMA Aware scheduling configuration to be used by the kubernetes workloads."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#metal-lb-configuration"},"Metal LB configuration"),": Metal LB configuration to be used by the kubernetes workloads.")),(0,r.kt)("h2",{id:"bios-configuration"},"Bios configuration"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("em",{parentName:"p"},"Note"),": This configuration depends on the hardware vendor, so please, check with your hardware vendor the best configuration to be used.")),(0,r.kt)("p",null,"This section is really important to optimize the performance of the real time kernel in the hardware, because some of this parameters could increase not limiting the performance of the real time kernel.\nThe next table shows the recommended configuration for the most common hardware vendors:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Option"),(0,r.kt)("th",{parentName:"tr",align:null},"Value"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Workload Profile"),(0,r.kt)("td",{parentName:"tr",align:null},"Telco Optimized"),(0,r.kt)("td",{parentName:"tr",align:null},"Telco profile to optimize the performance in the hardware.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Boot Performance Mode"),(0,r.kt)("td",{parentName:"tr",align:null},"Max. Performance"),(0,r.kt)("td",{parentName:"tr",align:null},"Maximize the performance in the boot process.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Hyper- Threading (Logical Proccesor)"),(0,r.kt)("td",{parentName:"tr",align:null},"Enable"),(0,r.kt)("td",{parentName:"tr",align:null},"This option enables Intel\xae Hyper-Threading Technology for logical processor enabling and converting processor cores (pCores) to logical cores (lCores).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Virtualization Technology (XAPIC)"),(0,r.kt)("td",{parentName:"tr",align:null},"Enable"),(0,r.kt)("td",{parentName:"tr",align:null},"This option is for Extended Advanced Programmable Interrupt Controller (xAPIC) support for the Intel\xae Virtualization Technology for Directed I/O (Intel\xae VT-d) feature.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uncore frequency scaling"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"If enabled, Uncore Frequency Scaling (UFS) allows the uncore to operate at a lower frequency when the Power Control Unit (PCU) has detected low utilization. Conversely, UFS allows the uncore to operate at a higher frequency when the PCU has detected high utilization.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CPU P-State Control (EIST PSD Function"),(0,r.kt)("td",{parentName:"tr",align:null},"HW_ALL"),(0,r.kt)("td",{parentName:"tr",align:null},"optimization of the voltage and CPU fequency during operation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CPU C-State Control"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"This option is for the CPU C-State Control feature, which provides power savings by placing the processor into lower power states when the processor is idle.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"CPU C1E Support"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"This option is for the CPU Enhanced Halt (C1E) feature, which provides power savings by placing the processor into a low power state when the processor is idle.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AVX License Pre-Grant"),(0,r.kt)("td",{parentName:"tr",align:null},"Enable"),(0,r.kt)("td",{parentName:"tr",align:null},"If enabled, this option enables the pre-grant license level selection based on workload with the AVX ICCP Pre-Grant Level option.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AVX ICCP Pre- Grant Level"),(0,r.kt)("td",{parentName:"tr",align:null},"Level 5"),(0,r.kt)("td",{parentName:"tr",align:null},"This option selects a workload level for the Intel\xae Advanced Vector Extensions (Intel\xae AVX): Intel\xae AVX-512 Heavy")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"AVX P1"),(0,r.kt)("td",{parentName:"tr",align:null},"Level 2"),(0,r.kt)("td",{parentName:"tr",align:null},"This option serves a dual purpose: 1 -Specifies the base P1 ratio for Intel\xae Streaming SIMD Extensions (Intel\xae SSE) or Intel\xae AVX workloads. 2- Pre-grants a license level based on the workload level.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Energy Efficient Turbo"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows entry into the Intel\xae Turbo Boost Technology frequency when the Power Control Unit (PCU) has detected high utilization.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Turbo Mode"),(0,r.kt)("td",{parentName:"tr",align:null},"Enable"),(0,r.kt)("td",{parentName:"tr",align:null},"Enabling this Intel\xae Turbo Boost Technology mode setting allows the CPU cores to operate at higher than the rated frequency.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"GPSS timer"),(0,r.kt)("td",{parentName:"tr",align:null},"0us"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows the reduction of the Global P-State Selection (GPSS) timer to be set from: 0 \u03bcs to 500 \u03bcs")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"LLC prefetch"),(0,r.kt)("td",{parentName:"tr",align:null},"Enable"),(0,r.kt)("td",{parentName:"tr",align:null},"This option enables Last Level Cache (LLC) hardware prefetch logic.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Frequency Prioritization (RAPL Prioritization)"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"This setting controls whether the Running Average Power Limit (RAPL) balancer is enabled. If enabled, it activates per core power budgeting.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Hardware P-States"),(0,r.kt)("td",{parentName:"tr",align:null},"Native with no Legacy Support"),(0,r.kt)("td",{parentName:"tr",align:null},"When enabled, this option allows the hardware to choose a Performance State (P-State) based on an OS request (that is, a legacy P-State).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"EPP enable3"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"When this option is enabled, the system uses the energy performance bias register for the Energy Performance Preference (EPP) input to make decision on Performance State (P-State) or Processor Core Idle State (C-State) transitions.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"APS Rocketing"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"Rocketing mechanism in the HWP p-state selection for pcode algorithm. Rocketing enables the core ratio to jump to max turbo instantaneously as opposed to a smooth ramp")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Scalability"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"Core Performance to frequency scalability based on optimizations in the CPU.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Native ASPM"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"ASPM off not controlled by BIOS or OS.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Power Performance Tuning"),(0,r.kt)("td",{parentName:"tr",align:null},"OS Controls EPB"),(0,r.kt)("td",{parentName:"tr",align:null},"This option selects the BIOS or OS that controls the Energy Performance Bias (EPB) functionality.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Workload Configuration"),(0,r.kt)("td",{parentName:"tr",align:null},"I/O sensitive"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows the system power and performance profile to be set to favor compute intensive workload or I/O sensitive workload.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Dynamic L1"),(0,r.kt)("td",{parentName:"tr",align:null},"Disable"),(0,r.kt)("td",{parentName:"tr",align:null},"This option applies only to the package-level setting to allow dynamically entering the lower power link state L1.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Set Fan Profile"),(0,r.kt)("td",{parentName:"tr",align:null},"Performance"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows the fan profile to be set to Performance, Balanced, or Quiet.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Cooling Configuration - Fan Speed Offset"),(0,r.kt)("td",{parentName:"tr",align:null},"Medium"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows the fan speed offset to be set to Low, Medium, or High.")))),(0,r.kt)("h2",{id:"kernel-real-time"},"Kernel Real Time"),(0,r.kt)("p",null,"The real time kernel image is not necessarily better than a standard kernel.\nIt is a different kernel tuned to a specific use case. The real time kernel is tuned for lower latency at the cost of throughput. The real time kernel is not recommended for general purpose use, but in our case, this is the recommended kernel for Telco Workloads."),(0,r.kt)("p",null,"There are 4 top features:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Deterministic Execution:")),(0,r.kt)("p",null,"Get greater predictability \u2013 ensure critical business processes complete in time, every time and deliver high quality of service, even under heavy system loads. By shielding key system resources for high-priority processes, you can ensure greater predictability for time-sensitive applications."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Low Jitter:")),(0,r.kt)("p",null,"The low jitter built upon the highly deterministic technology helps to keep applications synchronized with the real world. This helps services that need ongoing and repeated calculation."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Priority Inheritance:")),(0,r.kt)("p",null,"Priority inheritance refers to the ability of a lower priority process to assume a higher priority when there is a higher priority process that requires the lower priority process to finish before it can accomplish its task. SUSE Linux Enterprise Real Time solves these priority inversion problems for mission-critical processes."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Thread Interrupts:")),(0,r.kt)("p",null,"Processes running in interrupt mode in a general-purpose operating system are not preemptible. With SUSE Linux Enterprise Real Time these interrupts have been encapsulated by kernel threads, which are interruptible, and in turn allow the hard and soft interrupts to be preempted by user-defined higher priority processes."),(0,r.kt)("p",null,"In our case, if you have installed a real time image like SLE Micro RT, kernel real time is already installed and you don't need to install it again."),(0,r.kt)("p",null,"You could check it looking for the kernel and see if contains the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"rt"))," string at the end of the kernel info:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"uname -r\n5.14.21-150400.15.11-rt\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"For more information about the real time kernel, please visit ",(0,r.kt)("a",{parentName:"p",href:"https://www.suse.com/products/realtime/"},"https://www.suse.com/products/realtime/"))),(0,r.kt)("h2",{id:"cpu-tuned-configuration"},"CPU Tuned Configuration"),(0,r.kt)("p",null,"The first thing is to create a profile for the cpu cores we want to isolate. In this case, we will isolate the cores 1-30 and 33-62. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'echo "export tuned_params" >> /etc/grub.d/00_tuned\n\necho "isolated_cores=1-30,33-62" >> /etc/tuned/cpu-partitioning-variables.conf\n\ntuned-adm profile cpu-partitioning\nCannot talk to Tuned daemon via DBus. Is Tuned daemon running?\nTrying to (re)start tuned...\nTuned (re)started, changes applied.\n')),(0,r.kt)("p",null,"Then we need to modify grub option to isolate cpu cores as well as another important parameters for the cpu usage."),(0,r.kt)("p",null,"Modify in /etc/default/grub the next line, to add the cpu cores to isolate. The next options are the most important to be customized with your current hardware:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"value"),(0,r.kt)("th",{parentName:"tr",align:null},"description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"isolcpu"),(0,r.kt)("td",{parentName:"tr",align:null},"1-30,33-62"),(0,r.kt)("td",{parentName:"tr",align:null},"Isolate the cores 1-30 and 33-62")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"skew_tick"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows the kernel to skew the timer interrupts across the isolated CPUs.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nohz"),(0,r.kt)("td",{parentName:"tr",align:null},"on"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows the kernel to run the timer tick on a single CPU when the system is idle.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"nohz_full"),(0,r.kt)("td",{parentName:"tr",align:null},"1-30,33-62"),(0,r.kt)("td",{parentName:"tr",align:null},"kernel boot parameter is the current main interface to configure full dynticks along with CPU Isolation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"rcu_nocbs"),(0,r.kt)("td",{parentName:"tr",align:null},"1-30,33-62"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows the kernel to run the RCU callbacks on a single CPU when the system is idle.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"kthread_cpus"),(0,r.kt)("td",{parentName:"tr",align:null},"0,31,32,63"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows the kernel to run the kthreads on a single CPU when the system is idle.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"irqaffinity"),(0,r.kt)("td",{parentName:"tr",align:null},"0,31,32,63"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows the kernel to run the interrupts on a single CPU when the system is idle.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"processor.max_cstate"),(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"This option prevents the CPU from dropping into a sleep state when idle")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"intel_idle.max_cstate"),(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"This option disables the intel_idle driver and allows acpi_idle to be used")))),(0,r.kt)("p",null,"With the values showed above, we are isolating 60 cores, and we are using 4 cores for the OS."),(0,r.kt)("p",null,"Let's modify the grub file with the previous values:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'vi /boot/efi/EFI/sle_rt/grub.cfg\n    set tuned_params="skew_tick=1 nohz=on nohz_full=1-30,33-62 rcu_nocbs=1-30,33-62 tuned.non_isolcpus=80000001,80000001 nosoftlockup"\n\nvi /etc/default/grub\n    GRUB_CMDLINE_LINUX="intel_iommu=on intel_pstate=passive processor.max_cstate=1 intel_idle.max_cstate=0 iommu=pt usbcore.autosuspend=-1 selinux=0 enforcing=0 nmi_watchdog=0 crashkernel=auto softlockup_panic=0 audit=0 mce=off hugepagesz=1G hugepages=40 hugepagesz=2M hugepages=0 default_hugepagesz=1G kthread_cpus=0,31,32,63 irqaffinity=0,31,32,63 isolcpu=1-30,33-62 skew_tick=1 nohz_full=1-30,33-62 rcu_nocbs=1-30,33-62 rcu_nocb_poll"\n\ntransactional-update grub.cfg\n')),(0,r.kt)("p",null,"To validate that the parameters are applied after reboot, you could check:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cat /proc/cmdline\n")),(0,r.kt)("h2",{id:"multus--calico"},"Multus + Calico"),(0,r.kt)("p",null,"Multus CNI is a CNI plugin that enables attaching multiple network interfaces to pods. Multus does not replace CNI plugins, instead it acts as a CNI plugin multiplexer. Multus is useful in certain use cases, especially when pods are network intensive and require extra network interfaces that support dataplane acceleration techniques such as SR-IOV."),(0,r.kt)("p",null,"Multus can not be deployed standalone. It always requires at least one conventional CNI plugin that fulfills the Kubernetes cluster network requirements. That CNI plugin becomes the default for Multus, and will be used to provide the primary interface for all pods.\nIn our case, most of the workloads in Telco will be deployed using Multus + calico."),(0,r.kt)("p",null,"To enable Multus on RKE2 cluster, add multus as the first list entry in the cni config key, followed by the name of the plugin you want to use alongside Multus (or none if you will provide your own default plugin). Note that multus must always be in the first position of the list. For example, to use Multus with calico as the default plugin you could specify:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"# /etc/rancher/rke2/config.yaml\ncni:\n- multus\n- calico\n")),(0,r.kt)("p",null,"This can also be specified with command-line arguments, i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"--cni=multus,calico")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"--cni=multus --cni=calico"),"."),(0,r.kt)("p",null,"You could also install Multus directly during the edge cluster installation:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"multus.png",src:n(8122).Z,width:"1667",height:"878"})),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"For more information about Multus, please visit ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/k8snetworkplumbingwg/multus-cni"},"https://github.com/k8snetworkplumbingwg/multus-cni")),(0,r.kt)("p",{parentName:"blockquote"},"For more information about CNI plugins, please visit ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rke2.io/install/network_options"},"https://docs.rke2.io/install/network_options"))),(0,r.kt)("h2",{id:"sriov"},"SRIOV"),(0,r.kt)("p",null,"SR-IOV allows a device, such as a network adapter, to separate access to its resources among various PCIe hardware functions.\nThere are different ways to deploy SRIOV, and in this case, we will show two different options:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Option 1: using the SRIOV CNI device plugins and a config map to configure it properly.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Option 2: using the SRIOV helm chart from Rancher to make this deployment easy."))),(0,r.kt)("h3",{id:"option-1---installation-of-sr-iov-cni-device-plugins-and-a-config-map-to-configure-it-properly"},"Option 1 - Installation of SR-IOV CNI device plugins and a config map to configure it properly"),(0,r.kt)("h4",{id:"prepare-the-config-map-for-the-device-plugin"},"Prepare the config map for the device plugin"),(0,r.kt)("p",null,"You could get the information to fill the config map from the lspci command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"lspci | grep -i acc\n8a:00.0 Processing accelerators: Intel Corporation Device 0d5c\n\nlspci | grep -i net\nxr11-1:~ # lspci | grep -i net\n19:00.0 Ethernet controller: Broadcom Inc. and subsidiaries BCM57504 NetXtreme-E 10Gb/25Gb/40Gb/50Gb/100Gb/200Gb Ethernet (rev 11)\n19:00.1 Ethernet controller: Broadcom Inc. and subsidiaries BCM57504 NetXtreme-E 10Gb/25Gb/40Gb/50Gb/100Gb/200Gb Ethernet (rev 11)\n19:00.2 Ethernet controller: Broadcom Inc. and subsidiaries BCM57504 NetXtreme-E 10Gb/25Gb/40Gb/50Gb/100Gb/200Gb Ethernet (rev 11)\n19:00.3 Ethernet controller: Broadcom Inc. and subsidiaries BCM57504 NetXtreme-E 10Gb/25Gb/40Gb/50Gb/100Gb/200Gb Ethernet (rev 11)\n51:00.0 Ethernet controller: Intel Corporation Ethernet Controller E810-C for QSFP (rev 02)\n51:00.1 Ethernet controller: Intel Corporation Ethernet Controller E810-C for QSFP (rev 02)\n51:01.0 Ethernet controller: Intel Corporation Ethernet Adaptive Virtual Function (rev 02)\n51:01.1 Ethernet controller: Intel Corporation Ethernet Adaptive Virtual Function (rev 02)\n51:01.2 Ethernet controller: Intel Corporation Ethernet Adaptive Virtual Function (rev 02)\n51:01.3 Ethernet controller: Intel Corporation Ethernet Adaptive Virtual Function (rev 02)\n51:11.0 Ethernet controller: Intel Corporation Ethernet Adaptive Virtual Function (rev 02)\n51:11.1 Ethernet controller: Intel Corporation Ethernet Adaptive Virtual Function (rev 02)\n51:11.2 Ethernet controller: Intel Corporation Ethernet Adaptive Virtual Function (rev 02)\n51:11.3 Ethernet controller: Intel Corporation Ethernet Adaptive Virtual Function (rev 02)\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("inlineCode",{parentName:"p"},"0d5d")," is the VF from the FEC card (take a look that it's different than the lspci | grep acc result, because it's the VF, not the PF). Normally it's the first VF of the card, so the last name will be consecutive after VF creation.")),(0,r.kt)("p",null,"The config map consists of a JSON file that describe devices using filters to discover and creates some groups for the interfaces.\nThe most important is to understand the filters and the groups. The filters are used to discover the devices and the groups are used to create the interfaces."),(0,r.kt)("p",null,"For example, we could filter using:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"vendorID: ",(0,r.kt)("inlineCode",{parentName:"li"},"8086")," (Intel)"),(0,r.kt)("li",{parentName:"ul"},"deviceID: ",(0,r.kt)("inlineCode",{parentName:"li"},"0d5d")," (FEC)"),(0,r.kt)("li",{parentName:"ul"},"driver: ",(0,r.kt)("inlineCode",{parentName:"li"},"vfio-pci")," (SRIOV driver)"),(0,r.kt)("li",{parentName:"ul"},"pfNames: ",(0,r.kt)("inlineCode",{parentName:"li"},"p2p1")," (PF name)")),(0,r.kt)("p",null,"We could also set placesholders like:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"pfNames: ",'["eth1#1,2,3,4,5,6"]'," ")),(0,r.kt)("p",null,"Regarding the groups, we could create a group for the FEC card and another group for the Intel card even creating some prefix depending our use case:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"resourceName: ",(0,r.kt)("inlineCode",{parentName:"li"},"pci_sriov_net_bh_dpdk")),(0,r.kt)("li",{parentName:"ul"},"resourcePrefix: ",(0,r.kt)("inlineCode",{parentName:"li"},"Rancher.io"))),(0,r.kt)("p",null,"There are a lot of combinations in order to discover and create the resource group to allocate some VFs to the pods."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"For more information about the filters and groups, please visit ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/k8snetworkplumbingwg/sriov-network-device-plugin"},"https://github.com/k8snetworkplumbingwg/sriov-network-device-plugin"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'cat <<EOF | k apply -f -\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: sriovdp-config\n  namespace: kube-system\ndata:\n  config.json: |\n    {\n        "resourceList": [\n            {\n                "resourceName": "intel_fec_5g",\n                "devicetype": "accelerator",\n                "selectors": {\n                    "vendors": ["8086"],\n                    "devices": ["0d5d"]\n                }\n            },\n            {\n                "resourceName": "intel_sriov_odu",\n                "selectors": {\n                    "vendors": ["8086"],\n                    "devices": ["1889"],\n                    "drivers": ["vfio-pci"],\n                    "pfNames": ["p2p1"]\n                }\n            },\n            {\n                "resourceName": "intel_sriov_oru",\n                "selectors": {\n                    "vendors": ["8086"],\n                    "devices": ["1889"],\n                    "drivers": ["vfio-pci"],\n                    "pfNames": ["p2p2"]\n                }\n            }\n        ]\n    }\nEOF\n')),(0,r.kt)("h4",{id:"prepare-the-daemonset-for-the-device-plugin"},"Prepare the daemonset for the device plugin"),(0,r.kt)("p",null,"No changes are needed in the daemonset, so you can use the same upstream daemonset file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'cat <<EOF | k apply -f -\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: sriov-device-plugin\n  namespace: kube-system\n\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: kube-sriov-device-plugin-amd64\n  namespace: kube-system\n  labels:\n    tier: node\n    app: sriovdp\nspec:\n  selector:\n    matchLabels:\n      name: sriov-device-plugin\n  template:\n    metadata:\n      labels:\n        name: sriov-device-plugin\n        tier: node\n        app: sriovdp\n    spec:\n      hostNetwork: true\n      nodeSelector:\n        kubernetes.io/arch: amd64\n      tolerations:\n      - key: node-role.kubernetes.io/master\n        operator: Exists\n        effect: NoSchedule\n      serviceAccountName: sriov-device-plugin\n      containers:\n      - name: kube-sriovdp\n        image: ghcr.io/k8snetworkplumbingwg/sriov-network-device-plugin:latest-amd64\n        imagePullPolicy: IfNotPresent\n        args:\n        - --log-dir=sriovdp\n        - --log-level=10\n        securityContext:\n          privileged: true\n        resources:\n          requests:\n            cpu: "250m"\n            memory: "40Mi"\n          limits:\n            cpu: 1\n            memory: "200Mi"\n        volumeMounts:\n        - name: devicesock\n          mountPath: /var/lib/kubelet/\n          readOnly: false\n        - name: log\n          mountPath: /var/log\n        - name: config-volume\n          mountPath: /etc/pcidp\n        - name: device-info\n          mountPath: /var/run/k8s.cni.cncf.io/devinfo/dp\n      volumes:\n        - name: devicesock\n          hostPath:\n            path: /var/lib/kubelet/\n        - name: log\n          hostPath:\n            path: /var/log\n        - name: device-info\n          hostPath:\n            path: /var/run/k8s.cni.cncf.io/devinfo/dp\n            type: DirectoryOrCreate\n        - name: config-volume\n          configMap:\n            name: sriovdp-config\n            items:\n            - key: config.json\n              path: config.json\nEOF\n')),(0,r.kt)("p",null,"After that you should see the pods running:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"kubectl get pods -n kube-system | grep sriov\nkube-system       kube-sriov-device-plugin-amd64-twjfl                    1/1     Running   0          2m\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Check the interfaces discovered and available in the nodes to be used by the pods:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'kubectl get $(kubectl get nodes -oname) -o jsonpath=\'{.status.allocatable}\' | jq\n{\n  "cpu": "64",\n  "ephemeral-storage": "256196109726",\n  "hugepages-1Gi": "40Gi",\n  "hugepages-2Mi": "0",\n  "intel.com/intel_fec_5g": "1",\n  "intel.com/intel_sriov_odu": "4",\n  "intel.com/intel_sriov_oru": "4",\n  "memory": "221396384Ki",\n  "pods": "110"\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The FEC will be ",(0,r.kt)("inlineCode",{parentName:"p"},"intel.com/intel_fec_5g")," and the value will be 1 ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The VF will be ",(0,r.kt)("inlineCode",{parentName:"p"},"intel.com/intel_sriov_odu")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"intel.com/intel_sriov_oru")," if you deploy it with device plugin and the config map without helm charts"))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Important Note"),": If you don't get the interfaces available here, does not make sense continue with the workload, because interface will not be available for pods ")),(0,r.kt)("h3",{id:"option-2---installation-using-rancher-using-helm-chart-for-sr-iov-cni-and-device-plugins"},"Option 2 - Installation using Rancher using Helm chart for SR-IOV CNI and device plugins"),(0,r.kt)("h4",{id:"get-helm-if-not-present"},"Get helm if not present"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3\nchmod 500 get_helm.sh\n./get_helm.sh\n")),(0,r.kt)("h4",{id:"install-sriov"},"Install SRIOV"),(0,r.kt)("p",null,"This part could be done in two ways, using the CLI or using the Rancher UI"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Install Operator from CLI")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"helm repo add rancher-charts https://raw.githubusercontent.com/rancher/charts/dev-v2.7/\nhelm install sriov-crd rancher-charts/sriov-crd\nhelm install sriov rancher-charts/sriov -n kube-system\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Install Operator from Rancher UI")),(0,r.kt)("p",null,"Once your cluster is installed and you have access to the Rancher UI, you can install the SR-IOV Operator from the Rancher UI from the apps tab:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"sriov.png",src:n(5063).Z,width:"1749",height:"914"})),(0,r.kt)("h4",{id:"check-the--deployed-resources-crd-and-pods"},"Check the  deployed resources crd and pods"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"kubectl -n sriov-network-operator get crd")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"kubectl -n sriov-network-operator get pods")),(0,r.kt)("h4",{id:"check-the-label-in-the-nodes"},"Check the label in the nodes"),(0,r.kt)("p",null,"Now, if you have all resources running, the label should appears automatically in your node:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'kubectl get nodes -oyaml | grep feature.node.kubernetes.io/network-sriov.capable\n    feature.node.kubernetes.io/network-sriov.capable: "true"\n')),(0,r.kt)("p",null,"if not present, you can add it manually:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"kubectl label $(kubectl get nodes -oname) feature.node.kubernetes.io/network-sriov.capable=true\n")),(0,r.kt)("h4",{id:"review-the-daemonset-to-see-the-new-sriov-network-config-daemon-and-sriov-rancher-nfd-worker-as-active-and-ready"},"Review the daemonset to see the new ",(0,r.kt)("inlineCode",{parentName:"h4"},"sriov-network-config-daemon")," and ",(0,r.kt)("inlineCode",{parentName:"h4"},"sriov-rancher-nfd-worker")," as active and ready"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"kubectl get daemonset -A\nNAMESPACE             NAME                            DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR                                           AGE\ncalico-system         calico-node                     1         1         1       1            1           kubernetes.io/os=linux                                  15h\ncattle-sriov-system   sriov-network-config-daemon     1         1         1       1            1           feature.node.kubernetes.io/network-sriov.capable=true   45m\ncattle-sriov-system   sriov-rancher-nfd-worker        1         1         1       1            1           <none>                                                  45m\nkube-system           rke2-ingress-nginx-controller   1         1         1       1            1           kubernetes.io/os=linux                                  15h\nkube-system           rke2-multus-ds                  1         1         1       1            1           kubernetes.io/arch=amd64,kubernetes.io/os=linux         15h\n")),(0,r.kt)("p",null,"After some minutes (can take up to 10 min to be updated) the nodes detected and configured will appear:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"kubectl get sriovnetworknodestates.sriovnetwork.openshift.io -A\nNAMESPACE             NAME     AGE\ncattle-sriov-system   xr11-2   83s\n")),(0,r.kt)("h4",{id:"check-the-interfaces-detected"},"Check the interfaces detected"),(0,r.kt)("p",null,"the interfaces discovered should be the pci address of the network device. Check this information with lspci command in the host."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'$ kubectl get sriovnetworknodestates.sriovnetwork.openshift.io -n kube-system -oyaml\napiVersion: v1\nitems:\n- apiVersion: sriovnetwork.openshift.io/v1\n  kind: SriovNetworkNodeState\n  metadata:\n    creationTimestamp: "2023-06-07T09:52:37Z"\n    generation: 1\n    name: xr11-2\n    namespace: cattle-sriov-system\n    ownerReferences:\n    - apiVersion: sriovnetwork.openshift.io/v1\n      blockOwnerDeletion: true\n      controller: true\n      kind: SriovNetworkNodePolicy\n      name: default\n      uid: 80b72499-e26b-4072-a75c-f9a6218ec357\n    resourceVersion: "356603"\n    uid: e1f1654b-92b3-44d9-9f87-2571792cc1ad\n  spec:\n    dpConfigVersion: "356507"\n  status:\n    interfaces:\n    - deviceID: "1592"\n      driver: ice\n      eSwitchMode: legacy\n      linkType: ETH\n      mac: 40:a6:b7:9b:35:f0\n      mtu: 1500\n      name: p2p1\n      pciAddress: "0000:51:00.0"\n      totalvfs: 128\n      vendor: "8086"\n    - deviceID: "1592"\n      driver: ice\n      eSwitchMode: legacy\n      linkType: ETH\n      mac: 40:a6:b7:9b:35:f1\n      mtu: 1500\n      name: p2p2\n      pciAddress: "0000:51:00.1"\n      totalvfs: 128\n      vendor: "8086"\n    syncStatus: Succeeded\nkind: List\nmetadata:\n  resourceVersion: ""\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: If your interface is not detected here you should ensure that it is present in the next config map"),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre"},"kubectl get cm supported-nic-ids -oyaml -n cattle-sriov-system\n")),(0,r.kt)("p",{parentName:"blockquote"},"if your device is not there you have to edit the config map adding the right values to be discovered (should be necessary to restart the daemonset sriov-network-config-daemon)")),(0,r.kt)("h4",{id:"create-the-networknode-policy-to-configure-the-vfs"},"Create the NetworkNode Policy to configure the VFs"),(0,r.kt)("p",null,"Basically, you will create some VFs (",(0,r.kt)("inlineCode",{parentName:"p"},"numVfs"),") from the device (",(0,r.kt)("inlineCode",{parentName:"p"},"rootDevices"),") and will be configured with the driver (",(0,r.kt)("inlineCode",{parentName:"p"},"deviceType"),") and the MTU (",(0,r.kt)("inlineCode",{parentName:"p"},"mtu"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'cat <<EOF | kubectl apply -f -\napiVersion: sriovnetwork.openshift.io/v1\nkind: SriovNetworkNodePolicy\nmetadata:\n  name: policy-dpdk\n  namespace: kube-system\nspec:\n  nodeSelector:\n    feature.node.kubernetes.io/network-sriov.capable: "true"\n  resourceName: intelnicsDpdk\n  deviceType: vfio-pci\n  numVfs: 8\n  mtu: 1500\n  nicSelector:\n    deviceID: "1592"\n    vendor: "8086"\n    rootDevices:\n    - 0000:51:00.0\nEOF\n')),(0,r.kt)("h4",{id:"validate-configurations"},"Validate configurations"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'kubectl get $(kubectl get nodes -oname) -o jsonpath=\'{.status.allocatable}\' | jq\n{\n  "cpu": "64",\n  "ephemeral-storage": "256196109726",\n  "hugepages-1Gi": "60Gi",\n  "hugepages-2Mi": "0",\n  "intel.com/intel_fec_5g": "1",\n  "memory": "200424836Ki",\n  "pods": "110",\n  "rancher.io/intelnicsDpdk": "8"\n}\n')),(0,r.kt)("h4",{id:"create-the-sriov-network-optional-in-case-we-need-a-different-network"},"Create the sriov network (Optional, in case we need a different network):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'cat <<EOF | k apply -f -\napiVersion: sriovnetwork.openshift.io/v1\nkind: SriovNetwork\nmetadata:\n  name: network-dpdk\n  namespace: kube-system\nspec:\n  ipam: |\n    {\n      "type": "host-local",\n      "subnet": "192.168.0.0/24",\n      "rangeStart": "192.168.0.20",\n      "rangeEnd": "192.168.0.60",\n      "routes": [{\n        "dst": "0.0.0.0/0"\n      }],\n      "gateway": "192.168.0.1"\n    }\n  vlan: 500 \n  resourceName: intelnicsDpdk\nEOF\n')),(0,r.kt)("p",null,"Check the network created:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'kubectl get network-attachment-definitions.k8s.cni.cncf.io -A -oyaml\n\napiVersion: v1\nitems:\n- apiVersion: k8s.cni.cncf.io/v1\n  kind: NetworkAttachmentDefinition\n  metadata:\n    annotations:\n      k8s.v1.cni.cncf.io/resourceName: rancher.io/intelnicsDpdk\n    creationTimestamp: "2023-06-08T11:22:27Z"\n    generation: 1\n    name: network-dpdk\n    namespace: kube-system\n    resourceVersion: "13124"\n    uid: df7c89f5-177c-4f30-ae72-7aef3294fb15\n  spec:\n    config: \'{ "cniVersion":"0.3.1", "name":"network-dpdk","type":"sriov","vlan":500,"vlanQoS":0,"ipam":{"type":"host-local","subnet":"192.168.0.0/24","rangeStart":"192.168.0.10","rangeEnd":"192.168.0.60","routes":[{"dst":"0.0.0.0/0"}],"gateway":"192.168.0.1"}\n      }\'\nkind: List\nmetadata:\n  resourceVersion: ""\n')),(0,r.kt)("h2",{id:"dpdk"},"DPDK"),(0,r.kt)("h3",{id:"kernel-parameters"},"Kernel parameters"),(0,r.kt)("p",null,"To use dpdk using some drivers we need to enable some parameters in the kernel:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"value"),(0,r.kt)("th",{parentName:"tr",align:null},"description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"iommu"),(0,r.kt)("td",{parentName:"tr",align:null},"pt"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows to use vfio for the dpdk interfaces")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"intel_iommu"),(0,r.kt)("td",{parentName:"tr",align:null},"on"),(0,r.kt)("td",{parentName:"tr",align:null},"This option enables to use vfio for VFs.")))),(0,r.kt)("p",null,"To enable this parameters we need to add them to the kernel command line:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"vi /etc/default/grub\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'GRUB_CMDLINE_LINUX="intel_iommu=on intel_pstate=passive processor.max_cstate=1 intel_idle.max_cstate=0 iommu=pt usbcore.autosuspend=-1 selinux=0 enforcing=0 nmi_watchdog=0 crashkernel=auto softlockup_panic=0 audit=0 mce=off hugepagesz=1G hugepages=40 hugepagesz=2M hugepages=0 default_hugepagesz=1G kthread_cpus=0,31,32,63 irqaffinity=0,31,32,63 isolcpu=1-30,33-62 skew_tick=1 nohz_full=1-30,33-62 rcu_nocbs=1-30,33-62 rcu_nocb_poll"\n')),(0,r.kt)("p",null,"Then you need to update the grub configuration and reboot the system to apply the changes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"transactional-update grub.cfg\nreboot\n")),(0,r.kt)("p",null,"To validate that the parameters are applied after the reboot you can check the command line:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cat /proc/cmdline\n")),(0,r.kt)("h3",{id:"load-vfio-pci-kernel-module"},"Load vfio-pci kernel module"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"modprobe vfio-pci\n")),(0,r.kt)("h3",{id:"create-vfs-from-the-nics"},"Create VFs from the NICs"),(0,r.kt)("p",null,"To create 4 VFs PCI addresses for example for 2 different NICs we need to execute the following commands:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"echo 4 > /sys/bus/pci/devices/0000:51:00.0/sriov_numvfs\n\necho 4 > /sys/bus/pci/devices/0000:51:00.1/sriov_numvfs\n")),(0,r.kt)("h3",{id:"bind-the-new-vfs-with-the-vfio-pci-driver"},"Bind the new VFs with the vfio-pci driver"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"dpdk-devbind.py -b vfio-pci 0000:51:01.0 0000:51:01.1 0000:51:01.2 0000:51:01.3 0000:51:11.0 0000:51:11.1 0000:51:11.2 0000:51:11.3\n")),(0,r.kt)("h3",{id:"review-the-configuration-applied"},"Review the configuration applied:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"dpdk-devbind.py -s\n\nNetwork devices using DPDK-compatible driver\n============================================\n0000:51:01.0 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n0000:51:01.1 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n0000:51:01.2 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n0000:51:01.3 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n0000:51:01.0 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n0000:51:11.1 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n0000:51:21.2 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n0000:51:31.3 'Ethernet Adaptive Virtual Function 1889' drv=vfio-pci unused=iavf,igb_uio\n\nNetwork devices using kernel driver\n===================================\n0000:19:00.0 'BCM57504 NetXtreme-E 10Gb/25Gb/40Gb/50Gb/100Gb/200Gb Ethernet 1751' if=em1 drv=bnxt_en unused=igb_uio,vfio-pci *Active*\n0000:19:00.1 'BCM57504 NetXtreme-E 10Gb/25Gb/40Gb/50Gb/100Gb/200Gb Ethernet 1751' if=em2 drv=bnxt_en unused=igb_uio,vfio-pci\n0000:19:00.2 'BCM57504 NetXtreme-E 10Gb/25Gb/40Gb/50Gb/100Gb/200Gb Ethernet 1751' if=em3 drv=bnxt_en unused=igb_uio,vfio-pci\n0000:19:00.3 'BCM57504 NetXtreme-E 10Gb/25Gb/40Gb/50Gb/100Gb/200Gb Ethernet 1751' if=em4 drv=bnxt_en unused=igb_uio,vfio-pci\n0000:51:00.0 'Ethernet Controller E810-C for QSFP 1592' if=eth13 drv=ice unused=igb_uio,vfio-pci\n0000:51:00.1 'Ethernet Controller E810-C for QSFP 1592' if=rename8 drv=ice unused=igb_uio,vfio-pci\n\n")),(0,r.kt)("h2",{id:"huge-pages"},"Huge Pages"),(0,r.kt)("p",null,"When a process uses RAM, the CPU marks it as used by that process. For efficiency, the CPU allocates RAM in chunks\u20144K bytes is the default value on many platforms. Those chunks are named pages. Pages can be swapped to disk, etc."),(0,r.kt)("p",null,"Since the process address space is virtual, the CPU and the operating system need to remember which pages belong to which process, and where each page is stored. The more pages you have, the more time it takes to find where memory is mapped. When a process uses 1GB of memory, that's 262144 entries to look up (1GB / 4K). If one page table entry consume 8 bytes, that's 2MB (262144 * 8) to look up."),(0,r.kt)("p",null,"Most current CPU architectures support larger-than-default pages, which give the CPU/OS less entries to look-up."),(0,r.kt)("h3",{id:"kernel-parameters-1"},"Kernel parameters"),(0,r.kt)("p",null,"To enable the huge pages we should add the next kernel parameters:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"value"),(0,r.kt)("th",{parentName:"tr",align:null},"description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hugepagesz"),(0,r.kt)("td",{parentName:"tr",align:null},"1G"),(0,r.kt)("td",{parentName:"tr",align:null},"This options allows to set the size of huge pages to 1G")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hugepages"),(0,r.kt)("td",{parentName:"tr",align:null},"40"),(0,r.kt)("td",{parentName:"tr",align:null},"This is the number of hugepages defined before")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"default_hugepagesz"),(0,r.kt)("td",{parentName:"tr",align:null},"1G"),(0,r.kt)("td",{parentName:"tr",align:null},"This is the default value to get the huge pages")))),(0,r.kt)("p",null,"Modify the grub file to add them to the kernel command line:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"vi /etc/default/grub\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'GRUB_CMDLINE_LINUX="intel_iommu=on intel_pstate=passive processor.max_cstate=1 intel_idle.max_cstate=0 iommu=pt usbcore.autosuspend=-1 selinux=0 enforcing=0 nmi_watchdog=0 crashkernel=auto softlockup_panic=0 audit=0 mce=off hugepagesz=1G hugepages=40 hugepagesz=2M hugepages=0 default_hugepagesz=1G kthread_cpus=0,31,32,63 irqaffinity=0,31,32,63 isolcpu=1-30,33-62 skew_tick=1 nohz_full=1-30,33-62 rcu_nocbs=1-30,33-62 rcu_nocb_poll"\n')),(0,r.kt)("h3",{id:"usage-of-huge-pages"},"Usage of huge pages"),(0,r.kt)("p",null,"In order to use the huge pages we need to mount them:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"mkdir -p /hugepages\nmount -t hugetlbfs nodev /hugepages\n")),(0,r.kt)("p",null,"Now you could deploy your kubernetes workload creating the resources as well as the volumes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"... \n resources:\n   requests:\n     memory: \"24Gi\"\n     hugepages-1Gi: 16Gi\n     intel.com/intel_sriov_oru: '4'\n   limits:\n     memory: \"24Gi\"\n     hugepages-1Gi: 16Gi\n     intel.com/intel_sriov_oru: '4'\n...\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"...\nvolumeMounts:\n  - name: hugepage\n    mountPath: /hugepages\n...\nvolumes:\n  - name: hugepage\n    emptyDir:\n      medium: HugePages\n...\n")),(0,r.kt)("h2",{id:"cpu-pinning-configuration"},"CPU Pinning Configuration"),(0,r.kt)("h3",{id:"requirements"},"Requirements"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You must have the CPU tuned to the performance profile covered on this ",(0,r.kt)("a",{parentName:"li",href:"#cpu-tuned-configuration"},"section")),(0,r.kt)("li",{parentName:"ul"},"You must have the RKE2 cluster kubelet configured with the cpu management arguments covered on this ",(0,r.kt)("a",{parentName:"li",href:"/docs/product/atip/edge-site#cpu-management-policy"},"section"))),(0,r.kt)("h3",{id:"use-cpu-pinning-on-kubernetes"},"Use CPU Pinning on kubernetes"),(0,r.kt)("p",null,"There are three ways to use that feature using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Static Policy")," defined in kubelet depending on the requests and limits you define on your workload:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"BestEffort")," QoS Class: If you don't define any request or limit for CPU, the pod will be scheduled on the first CPU available on the system.")),(0,r.kt)("p",null,"An example to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"BestEffort")," QoS Class could be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"spec:\n  containers:\n  - name: nginx\n    image: nginx\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Burstable")," QoS Class: If you define a request for CPU, which is not equal to the limits, or maybe there is no CPU request.")),(0,r.kt)("p",null,"Examples to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Burstable")," QoS Class could be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'spec:\n  containers:\n  - name: nginx\n    image: nginx\n    resources:\n      limits:\n        memory: "200Mi"\n      requests:\n        memory: "100Mi"\n')),(0,r.kt)("p",null,"or"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'spec:\n  containers:\n  - name: nginx\n    image: nginx\n    resources:\n      limits:\n        memory: "200Mi"\n        cpu: "2"\n      requests:\n        memory: "100Mi"\n        cpu: "1"\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Guaranteed")," QoS Class: If you define a request for CPU, which is equal to the limits.")),(0,r.kt)("p",null,"An example to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Guaranteed")," QoS Class could be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'spec:\n  containers:\n    - name: nginx\n      image: nginx\n      resources:\n        limits:\n          memory: "200Mi"\n          cpu: "2"\n        requests:\n          memory: "200Mi"\n          cpu: "2"\n')),(0,r.kt)("h2",{id:"numa-aware-scheduling"},"NUMA Aware scheduling"),(0,r.kt)("p",null,"Non-Uniform Memory Access or Non-Uniform Memory Architecture (NUMA) is a physical memory design used in SMP (multiprocessors) architecture, where the memory access time depends on the memory location relative to a processor. Under NUMA, a processor can access its own local memory faster than non-local memory, that is, memory local to another processor or memory shared between processors."),(0,r.kt)("h3",{id:"identify-numa-nodes"},"Identify NUMA nodes"),(0,r.kt)("p",null,"To identify the NUMA nodes on your system you can use the next command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"numactl --hardware\navailable: 1 nodes (0)\nnode 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63\nnode 0 size: 257167 MB\nnode 0 free: 246390 MB\nnode distances:\nnode   0\n  0:  10\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")," In this case we have only one NUMA node"),(0,r.kt)("p",{parentName:"blockquote"},"NUMA has to enabled in the BIOS. If dmesg does not have records of numa initialization during bootup, then it is possible that NUMA related messages in the kernel ring buffer might have been overwritten.")),(0,r.kt)("h2",{id:"vran-acceleration-intel-acc100"},"VRAN Acceleration (Intel ACC100)"),(0,r.kt)("p",null,"As communications service providers move from 4G to 5G networks, many are adopting virtualized radio access network (vRAN) architectures for higher channel capacity and easier deployment of edge-based services and applications. vRAN solutions are ideally located to deliver low-latency services with the flexibility to increase or decrease capacity based on the volume of real-time traffic and demand on the network."),(0,r.kt)("h3",{id:"kernel-parameters-2"},"Kernel parameters"),(0,r.kt)("p",null,"To enable the vRAN acceleration we need to enable the following kernel parameters (if not present yet):"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"parameter"),(0,r.kt)("th",{parentName:"tr",align:null},"value"),(0,r.kt)("th",{parentName:"tr",align:null},"description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"iommu"),(0,r.kt)("td",{parentName:"tr",align:null},"pt"),(0,r.kt)("td",{parentName:"tr",align:null},"This option allows to use vfio for the dpdk interfaces")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"intel_iommu"),(0,r.kt)("td",{parentName:"tr",align:null},"on"),(0,r.kt)("td",{parentName:"tr",align:null},"This option enables to use vfio for VFs.")))),(0,r.kt)("p",null,"Modify the grub file to add them to the kernel command line:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"vi /etc/default/grub\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'GRUB_CMDLINE_LINUX="intel_iommu=on intel_pstate=passive processor.max_cstate=1 intel_idle.max_cstate=0 iommu=pt usbcore.autosuspend=-1 selinux=0 enforcing=0 nmi_watchdog=0 crashkernel=auto softlockup_panic=0 audit=0 mce=off hugepagesz=1G hugepages=40 hugepagesz=2M hugepages=0 default_hugepagesz=1G kthread_cpus=0,31,32,63 irqaffinity=0,31,32,63 isolcpu=1-30,33-62 skew_tick=1 nohz_full=1-30,33-62 rcu_nocbs=1-30,33-62 rcu_nocb_poll"\n')),(0,r.kt)("p",null,"Then you need to update the grub configuration and reboot the system to apply the changes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"transactional-update grub.cfg\nreboot\n")),(0,r.kt)("p",null,"To validate that the parameters are applied after the reboot you can check the command line:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cat /proc/cmdline\n")),(0,r.kt)("h3",{id:"load-igb_uio-and-vfio-pci-kernel-modules"},"Load igb_uio and vfio-pci kernel modules"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"modprobe igb_uio\nmodprobe vfio-pci\n")),(0,r.kt)("h3",{id:"get-interface-information-acc100"},"Get interface information Acc100"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Maybe in some cases (depending on the OS) you should add to the path the /sbin/ for the lspci command doing: ",(0,r.kt)("inlineCode",{parentName:"p"},"export PATH=$PATH:/sbin/"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"lspci | grep -i acc\n8a:00.0 Processing accelerators: Intel Corporation Device 0d5c\n")),(0,r.kt)("h3",{id:"bind-the-pf-with-igb_uio-module"},"Bind the PF with igb_uio module"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"dpdk-devbind.py -b igb_uio 0000:8a:00.0\n")),(0,r.kt)("h3",{id:"create-the-vfs-from-the-pf"},"Create the VFs from the PF"),(0,r.kt)("p",null,"To create 2 vfs from the PF and bind with vfio-pci follow the next steps:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"echo 2 > /sys/bus/pci/devices/0000:8a:00.0/max_vfs\ndpdk-devbind.py -b vfio-pci 0000:8b:00.0\n")),(0,r.kt)("h3",{id:"configure-acc100-with-the-proposed-configuration-file"},"Configure acc100 with the proposed configuration file"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"pf_bb_config ACC100 -c /opt/pf-bb-config/acc100_config_vf_5g.cfg\nTue Jun  6 10:49:20 2023:INFO:Queue Groups: 2 5GUL, 2 5GDL, 2 4GUL, 2 4GDL\nTue Jun  6 10:49:20 2023:INFO:Configuration in VF mode\nTue Jun  6 10:49:21 2023:INFO: ROM version MM 99AD92\nTue Jun  6 10:49:21 2023:WARN:* Note: Not on DDR PRQ version  1302020 != 10092020\nTue Jun  6 10:49:21 2023:INFO:PF ACC100 configuration complete\nTue Jun  6 10:49:21 2023:INFO:ACC100 PF [0000:8a:00.0] configuration complete!\n")),(0,r.kt)("h3",{id:"check-the-new-vfs-created-from-the-fec-pf"},"Check the new VFs created from the FEC PF:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"dpdk-devbind.py -s\n...\n...\n...\nBaseband devices using DPDK-compatible driver\n=============================================\n0000:8a:00.0 'Device 0d5c' drv=igb_uio unused=vfio-pci\n0000:8b:00.0 'Device 0d5d' drv=vfio-pci unused=igb_uio\n\nOther Baseband devices\n======================\n0000:8b:00.1 'Device 0d5d' unused=igb_uio,vfio-pci\n")),(0,r.kt)("h2",{id:"metal-lb-beta"},"Metal LB (Beta)"),(0,r.kt)("p",null,"TBC"))}d.isMDXComponent=!0},8122:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/multus-3938993e53a38e5e137f93dc7e4e90b3.png"},5063:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/sriov-bafde3df00f7d4faea8ffdcea7245133.png"}}]);